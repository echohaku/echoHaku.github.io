<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ECHOHAKU BLOG</title><link>https://echoHaku.github.io/</link><description>Recent content on ECHOHAKU BLOG</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 19 Jan 2026 10:06:48 +0800</lastBuildDate><atom:link href="https://echoHaku.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Serialize 到底是什麼？</title><link>https://echoHaku.github.io/posts/post_tech_1/</link><pubDate>Mon, 19 Jan 2026 10:06:48 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_tech_1/</guid><description>&lt;h2 id="名詞定義"&gt;名詞定義&lt;/h2&gt;
&lt;h3 id="序列化-serialization"&gt;序列化 &lt;code&gt;serialization&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;序列化是指 將記憶體中的物件（Object）依特定序列化機制，轉換成可儲存或可傳輸的線性格式（例如 bytes 或文字格式）過程。&lt;br&gt;
在物件被序列化之後，資料可以被存放在檔案中，或透過網路傳遞給另一個系統，並在必要時再被還原。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：序列化是一個廣義概念，實作方式包含 Java 原生序列化、JSON、XML、Protobuf 等，不同機制的行為與限制並不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="反序列化-deserializing"&gt;反序列化 &lt;code&gt;deserializing&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;反序列化是指&lt;strong&gt;將已序列化的資料，依原本的序列化機制，還原為記憶體中的物件狀態&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id="java-反序列化的執行順序"&gt;Java 反序列化的執行順序：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;依 package name 與 class name 尋找 class&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若找不到，會直接拋出 &lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比對 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;比對序列化資料中記錄的 UID 與目前 class 定義中的 UID&lt;/li&gt;
&lt;li&gt;若不一致，會拋出 &lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="serialversionuid"&gt;serialVersionUID&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;serialVersionUID&lt;/code&gt; 是 Java 原生序列化中，用來識別 class 版本的 ID，其目的在於&lt;strong&gt;控制反序列化時的版本相容性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="為什麼需要-serialversionuid"&gt;為什麼需要 serialVersionUID？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若 class &lt;strong&gt;未明確宣告 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;JVM 會根據 class 結構（欄位、方法、繼承關係等）自動產生&lt;/li&gt;
&lt;li&gt;只要 class 結構稍有變動，UID 就可能改變&lt;/li&gt;
&lt;li&gt;導致舊資料在反序列化時失敗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="範例說明"&gt;範例說明&lt;/h3&gt;
&lt;p&gt;假設：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;User&lt;/code&gt; class 原本包含欄位 &lt;code&gt;(name, age, phone)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;將其序列化並儲存在檔案 A 中&lt;/li&gt;
&lt;li&gt;後續版本中刪除了 &lt;code&gt;phone&lt;/code&gt; 欄位，並修改了 &lt;code&gt;toString()&lt;/code&gt; 方法
若 &lt;strong&gt;未明確指定 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;JVM 可能重新計算 UID&lt;/li&gt;
&lt;li&gt;嘗試反序列化檔案 A 時，會拋出 &lt;code&gt;InvalidClassException&lt;/code&gt;
若 &lt;strong&gt;有明確指定 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;JVM 會認定這仍是同一個 class&lt;/li&gt;
&lt;li&gt;即使欄位有所差異，仍允許反序列化（新欄位可能為預設值）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="serialversionuid-通常如何設定"&gt;serialVersionUID 通常如何設定？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直接指定固定值&lt;/strong&gt;
&lt;code&gt;private static final long serialVersionUID = 1L;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由工具或 JVM 根據 class 結構產生出一個 64-bit hash value（通常唯一）
&lt;ul&gt;
&lt;li&gt;package name&lt;/li&gt;
&lt;li&gt;class name&lt;/li&gt;
&lt;li&gt;繼承關係&lt;/li&gt;
&lt;li&gt;非 private 的方法與欄位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="所有-class-都設定為-1l的時候jvm會允許反序列化但可能會造成"&gt;所有 class 都設定為 1L的時候，JVM會允許反序列化，但可能會造成&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新欄位可能會直接是預設值&lt;/li&gt;
&lt;li&gt;舊資料結構可能與新邏輯不相容&lt;/li&gt;
&lt;li&gt;問題不一定會在反序列化當下立即暴露&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="什麼時候會建議都設定為-1l-"&gt;什麼時候會建議都設定為 1L ？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DTO&lt;/li&gt;
&lt;li&gt;Cache Object&lt;/li&gt;
&lt;li&gt;Session Object&lt;/li&gt;
&lt;li&gt;欄位變動後仍可以向後相容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="什麼時候應該要調整serialversionuid"&gt;什麼時候應該要調整SerialVersionUID？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;欄位意義改變&lt;/li&gt;
&lt;li&gt;移除欄位&lt;/li&gt;
&lt;li&gt;改變繼承結構&lt;/li&gt;
&lt;li&gt;改變 &lt;code&gt;transient&lt;/code&gt; / &lt;code&gt;non-transient&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;public class ExampleClass implements Serializable { 
	private static final long serialVersionUID = 1L;
	// class details... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="在java當中什麼時候該-implements-serializable"&gt;在JAVA當中什麼時候該 implements Serializable？&lt;/h2&gt;
&lt;p&gt;判斷標準：「物件會被轉換成 byte stream 並在 JVM 之外存活或傳遞」時，才需要 &lt;code&gt;implements Serializable&lt;/code&gt;&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.18 結業式拉</title><link>https://echoHaku.github.io/posts/post_git_20/</link><pubDate>Tue, 02 Dec 2025 09:07:04 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_20/</guid><description>&lt;p&gt;從 2025/09/25 一路的寫寫停停，兩個多月的時間轉眼就過去了，這個分享系列也總算迎來一個階段性的成果！回頭看看最初的初衷——希望能把自己學到的知識整理成有系統的內容——我必須坦白說：&lt;strong&gt;成果沒有我想像得那麼理想&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在整個過程中，我遭遇了比預期更多的挑戰。一開始我努力嘗試自己動手寫，但卡關的次數遠比預期多；後來乾脆直接請 AI 協助潤稿，再到最後甚至變成由 AI 產出文章，某種程度上算是向懶惰妥協、向時間與效率所做的妥協。回想整個過程，我遇到的主要困難大概包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;知識不夠扎實&lt;/strong&gt;：動筆時常常因為知識基礎不夠扎實而陷入停滯，寫到一半還得跳出去查資料，斷斷續續很難維持節奏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表達力不足&lt;/strong&gt;：明明腦中有概念，卻很難把想法完整、清楚地寫出來。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;視覺化表達能力不足&lt;/strong&gt;：很多觀念其實用圖示會更清晰，但礙於自己的繪圖能力不足、製作影片的能力可以說完全沒有，加上預估學習成本太高而裹足不前，只能用冗長的文字替代，效果也打了折扣。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些狀況讓我在剛開始就耗費了許多時間與心力，最後自然變得越寫越懶散。&lt;/p&gt;
&lt;p&gt;如果要替這次的分享打個分數，大概只有 60 分左右。雖然至少有交代完，也趕在今年結束前收尾，但內容深度與品質還有很大的進步空間。或許等過一段時間，等到知識重新沉澱、累積得再扎實一些，我會再把整個系列好好翻修一遍。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;下次我該怎麼調整？&lt;/strong&gt;&lt;br&gt;
我想，或許可以先把主題大綱確定好，每次只處理其中一小部分。平日慢慢蒐集資料，假日再花兩個小時整理成文章，這樣應該能在不造成太大壓力的情況下維持產出。至少，步調清楚了，寫起來應該也會比較踏實……吧？&lt;/p&gt;
&lt;p&gt;無論如何，還是很期待之後能帶來更完整、更成熟的文章分享！&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.17 進階工作流：Hooks、Patch 與 Cherry-Pick</title><link>https://echoHaku.github.io/posts/post_git_19/</link><pubDate>Thu, 27 Nov 2025 09:53:35 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_19/</guid><description>&lt;p&gt;我們已經學習了標準的 Git 指令、歷史管理和團隊協作模型（如 Git Flow）。然而，有時我們需要更精確地&lt;strong&gt;控制程式碼的傳輸&lt;/strong&gt;、&lt;strong&gt;強制執行團隊規範&lt;/strong&gt;，甚至處理&lt;strong&gt;離線的程式碼交換&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本篇將介紹三個屬於進階「配置與工作流」層次的工具：&lt;strong&gt;&lt;code&gt;Git hooks&lt;/code&gt;（自動化規範）、&lt;code&gt;Git patch&lt;/code&gt;（離線交換）&lt;/strong&gt; 以及 &lt;strong&gt;&lt;code&gt;git cherry-pick&lt;/code&gt;（精準移植）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="一git-hooks專案的自動化守衛"&gt;一、&lt;code&gt;Git hooks&lt;/code&gt;：專案的自動化守衛&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Git hooks&lt;/code&gt; 不是一個 Git 指令，而是一系列&lt;strong&gt;預定義的腳本（Scripts）&lt;/strong&gt;。當 Git 倉庫中發生特定事件（如 Commit 前、Push 前、接收 Commit 後）時，Git 會自動執行這些腳本。&lt;/p&gt;
&lt;h4 id="1-定義"&gt;1. 定義&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定義：&lt;/strong&gt; 一種客製化的自動化機制，讓開發者能夠在 Git 流程的特定階段（Hooks）插入自定義的檢查或動作，以避免不必要的錯誤並及時阻止進入下一個階段。這樣可以增加生產力，節省除錯及事後緊急bug fix的時間，CICD前也可以先檢查！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;檔案位置：&lt;/strong&gt; 所有的腳本都存放在每個本地倉庫的 &lt;strong&gt;&lt;code&gt;.git/hooks/&lt;/code&gt;&lt;/strong&gt; 目錄下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-發生情境與腳本類型"&gt;2. 發生情境與腳本類型&lt;/h4&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Hooks 類型&lt;/th&gt;
 &lt;th&gt;觸發時機&lt;/th&gt;
 &lt;th&gt;典型應用情境&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;pre-commit&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;在你輸入 Commit 訊息&lt;strong&gt;之前&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;執行 Lint（程式碼風格檢查）、自動格式化程式碼、執行單元測試。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;commit-msg&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;在你輸入 Commit 訊息&lt;strong&gt;之後&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;檢查 Commit 訊息格式（例如：必須以 &lt;code&gt;feat:&lt;/code&gt; 或 &lt;code&gt;fix:&lt;/code&gt; 開頭）。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;pre-push&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;在程式碼&lt;strong&gt;推送到遠端之前&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;確保分支已通過所有測試、防止你將敏感分支推送到公開倉庫。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;post-receive&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;遠端倉庫&lt;strong&gt;接收到 Push 之後&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;在伺服器上自動觸發網站部署（CI/CD）。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="3-相關指令與知識點"&gt;3. 相關指令與知識點&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;配置：&lt;/strong&gt; Hooks 腳本通常使用 Shell、Python 或 Node.js 編寫。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地限制：&lt;/strong&gt; 預設的 Hooks 是&lt;strong&gt;本地&lt;/strong&gt;且&lt;strong&gt;不會被 Commit&lt;/strong&gt; 到 Git 倉庫的。團隊通常需要使用 &lt;strong&gt;Husky&lt;/strong&gt; 等工具來強制或標準化 Hooks 配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中斷流程：&lt;/strong&gt; 如果一個 Hooks 腳本以非零狀態碼退出，它將&lt;strong&gt;中斷&lt;/strong&gt;當前的 Git 流程（例如：&lt;code&gt;pre-commit&lt;/code&gt; 腳本失敗會阻止 Commit 發生）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="二git-patch離線程式碼交換"&gt;二、&lt;code&gt;Git patch&lt;/code&gt;：離線程式碼交換&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Git patch&lt;/code&gt;（補丁）是一種將一個或多個 Commit 的&lt;strong&gt;變更內容&lt;/strong&gt;，打包成一個標準文字檔（&lt;code&gt;.patch&lt;/code&gt; 或 &lt;code&gt;.diff&lt;/code&gt; 檔）的方法。它主要用於&lt;strong&gt;無法直接使用 Git 遠端傳輸&lt;/strong&gt;的環境。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.16 效率小工具：Stash, Tag, Grep與 Reflog</title><link>https://echoHaku.github.io/posts/post_git_18/</link><pubDate>Wed, 26 Nov 2025 08:49:15 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_18/</guid><description>&lt;p&gt;在前面的篇章中，我們已經掌握了分支、合併、重寫歷史和遠端協作。本篇將介紹四個能顯著提升個人開發效率和專案穩定性的工具：&lt;strong&gt;&lt;code&gt;stash&lt;/code&gt; 應對緊急插單、&lt;code&gt;tag&lt;/code&gt; 標記正式版本、&lt;code&gt;grep&lt;/code&gt; 快速定位內容，以及 &lt;code&gt;reflog&lt;/code&gt; 拯救失誤。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="一git-stash臨時置物櫃應對緊急插單"&gt;一、&lt;code&gt;git stash&lt;/code&gt;：臨時置物櫃（應對緊急插單）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git stash&lt;/code&gt; 是 Git 用來應對「緊急情況」或「中斷工作」的最佳工具。它允許你在不 Commit 的情況下，暫存當前所有&lt;strong&gt;已追蹤&lt;/strong&gt;（Tracked）的變更（包括暫存區和工作目錄），讓你的工作目錄回到乾淨的狀態。&lt;/p&gt;
&lt;h4 id="1-定義"&gt;1. 定義&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定義：&lt;/strong&gt; 將工作目錄和暫存區中未提交的變更，儲存到一個私有的「堆棧（Stack）」中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 預設情況下，&lt;code&gt;git stash&lt;/code&gt; 並不會處理&lt;strong&gt;那些從未被 &lt;code&gt;git add&lt;/code&gt; 過的&lt;/strong&gt;新增檔案 (Untracked Files)，也就是新增的檔案並不會因為git stash 而被清掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-發生情境與指令"&gt;2. 發生情境與指令&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;情境 A (緊急切換)：&lt;/strong&gt; 你正在開發功能 A，但老闆要求你立即修復一個緊急 Bug。你需要切換分支，但不想 Commit 進行中的 A 程式碼。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;情境 B (Pull 衝突)：&lt;/strong&gt; 你的本地檔案有修改，但需要 &lt;code&gt;git pull&lt;/code&gt; 遠端更新。Git 會拒絕 &lt;code&gt;pull&lt;/code&gt;，因為怕覆蓋你的本地變更。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令：&lt;/strong&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# 將所有變更（未暫存+已暫存）儲存起來，工作目錄變乾淨
git stash push -m &amp;#34;功能A未完成的進度&amp;#34;

# 列出所有已儲存的暫存
git stash list 

# 應用（恢復）最新的暫存，但保留暫存紀錄
git stash apply 

# 應用並刪除最新的暫存（最常用）
git stash pop

# 儲存特定檔案：Stash 通常儲存所有內容，要儲存特定檔案需要配合 git stash push -- &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="二git-tag頒發正式證書標記穩定版本"&gt;二、&lt;code&gt;git tag&lt;/code&gt;：頒發正式證書（標記穩定版本）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git tag&lt;/code&gt; 用於為歷史中的某個特定 Commit 打上一個「&lt;strong&gt;永久的、有意義的名稱標籤&lt;/strong&gt;」。在 Git Flow 中，它通常在 &lt;code&gt;main&lt;/code&gt; 分支上發佈新版本時使用。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.15 `git flow`</title><link>https://echoHaku.github.io/posts/post_git_17/</link><pubDate>Tue, 25 Nov 2025 09:24:00 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_17/</guid><description>&lt;p&gt;在前面幾篇，我們掌握了如何使用 &lt;code&gt;git clone&lt;/code&gt; 取得程式碼，並透過 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt; 進行同步。然而，當一個團隊同時開發數十個功能時，如果每個人都直接在 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;master&lt;/code&gt; 分支上操作，專案歷史將會一團混亂。&lt;/p&gt;
&lt;p&gt;本篇將介紹業界最常用的&lt;strong&gt;結構化開發模型&lt;/strong&gt;—— &lt;strong&gt;Git Flow&lt;/strong&gt;，以及它如何搭配&lt;strong&gt;審核機制&lt;/strong&gt; &lt;strong&gt;Pull Request (PR)&lt;/strong&gt; 來確保程式碼品質與穩定性。&lt;/p&gt;
&lt;h2 id="一git-flow結構化的分支管理模型"&gt;一、Git Flow：結構化的分支管理模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定義：&lt;/strong&gt; Git Flow 通過定義五種不同角色的分支，來規範程式碼從開發、整合、發佈到修復的整個生命週期。&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;分支名稱&lt;/th&gt;
 &lt;th&gt;角色定位&lt;/th&gt;
 &lt;th&gt;發生情境&lt;/th&gt;
 &lt;th&gt;相關指令/操作&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;main&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;主要分支&lt;/strong&gt; (Production Ready)&lt;/td&gt;
 &lt;td&gt;永遠保持穩定、可部署的狀態。所有正式版本標籤（Tag）都打在這裡。&lt;/td&gt;
 &lt;td&gt;只能從 &lt;code&gt;release&lt;/code&gt; 或 &lt;code&gt;hotfix&lt;/code&gt; 合併進來，不會在此分支上做commit！&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;develop&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;整合分支&lt;/strong&gt; (Integration Branch)&lt;/td&gt;
 &lt;td&gt;所有開發分支的基準，從此分支開出&lt;code&gt;feature&lt;/code&gt; ，開發完後也都會合併到這裡。&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;feature/&amp;lt;name&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;功能分支&lt;/strong&gt; (Feature Branch)&lt;/td&gt;
 &lt;td&gt;開發新功能時，從 &lt;code&gt;develop&lt;/code&gt; 分支出來，完成後再合併回 &lt;code&gt;develop&lt;/code&gt;。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;git checkout -b feature/new-login&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;release/&amp;lt;ver&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;發佈分支&lt;/strong&gt; (Release Branch)&lt;/td&gt;
 &lt;td&gt;準備發佈新版本時，從 &lt;code&gt;develop&lt;/code&gt; merge到&lt;code&gt;release&lt;/code&gt;，進行最終 Bug 修復和版本號更新。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;git checkout -b release/1.0.0 develop&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;hotfix/&amp;lt;name&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;熱修分支&lt;/strong&gt; (Hotfix Branch)&lt;/td&gt;
 &lt;td&gt;當產品上線後發現 &lt;code&gt;main&lt;/code&gt; 分支有緊急 Bug 時，直接從 &lt;code&gt;main&lt;/code&gt; 分支出來修復，修復後須合併回 &lt;code&gt;main&lt;/code&gt; 和 &lt;code&gt;develop&lt;/code&gt;。&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Git Flow 的優點&lt;/p&gt;</description></item><item><title>《天職地圖》心得</title><link>https://echoHaku.github.io/posts/post_7/</link><pubDate>Thu, 20 Nov 2025 16:31:24 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_7/</guid><description>&lt;h2 id="why-this"&gt;Why this?&lt;/h2&gt;
&lt;p&gt;年底總會特別容易感到焦慮，好像時間又悄悄過去一年，但我卻沒真正走到哪裡。今年同樣出現這種「症頭」：懷疑自己是否在正確的道路上，日子很忙、事情很多，但心裡卻少了成就感和方向感，甚至開始覺得努力本身變得沉重。&lt;/p&gt;
&lt;p&gt;「努力了卻不快樂，那乾脆不要努力了？」&lt;br&gt;
這種想法反覆在腦海裡打轉，讓我意識到我的生活正在失去熱情與意義，所以我開始尋找一個不一樣的觀點，用一個不一樣的角度去重新看待自己的職涯與人生。&lt;/p&gt;
&lt;p&gt;在書店簡短翻閱了這本書後，發現它給了我一個截然不同的感受。以往談到「未來規劃」或「人生目標設定」，常常令人覺得嚴肅、沉重、需要非常小心對待，害怕走錯任何一步的恐懼感總是從書本裡面飄散出來；但這本書從封面設計到內頁排版，都散發著一種輕盈、愉快的氣息，尤其是那幅「地圖式」的圖文頁面，讓我瞬間明白：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原來規劃人生不是一場考試，而更像是一場遊戲、一次冒險。&lt;br&gt;
原來找到前進的路，也可以是有趣、安心、甚至有點可愛的事情！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就因為這份直覺的安定，我毫不猶豫地把書帶回家。&lt;/p&gt;
&lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
&lt;h3 id="找出理想的未來"&gt;找出理想的未來&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;理想的未來（目標）＝想獲得的東西（物質慾望）＋想成為的樣貌（精神慾望）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「天職」 = 實現理想未來的工作方式 = （喜歡 X 擅長）X 價值觀&lt;/p&gt;
&lt;h3 id="喜歡熱情你願意主動靠近的事"&gt;喜歡（熱情、你願意主動靠近的事）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所謂的喜歡，不是短暫的興奮，而是你「願意花時間」、「主動學習」且「樂此不疲」的事情。&lt;/li&gt;
&lt;li&gt;喜歡是會帶來&lt;strong&gt;動力&lt;/strong&gt;和&lt;strong&gt;持續性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;同時，喜歡做的事（想做的事）是指可以達成「理想未來」的手段、方式，&lt;br&gt;
&lt;strong&gt;要找出各式各樣可以實現「理想未來」的方式，不要受限於現實層面的可行性，而是列出所有可能性之後再選一個現在最想做的那一個。&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;不論大小都可以，&lt;strong&gt;只要可以達成目標不論是情的大小都很重要！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;發現這個方式不行，中途換方法也是可以的！&lt;/li&gt;
&lt;li&gt;方法可以有很多條，你只需要選擇其中之一開始走。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="擅長天賦強項"&gt;擅長（天賦、強項）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;強項：在達成目標過程中「&lt;strong&gt;對自己有利的特徵&lt;/strong&gt;」而不是我一定有什麼才華、實績（證照、名次等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;「&lt;strong&gt;目標不同，所需要的強項也會不同。沒有「萬用強項」，只有「對這個目標特別好用的特質&lt;/strong&gt;」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;帶來&lt;strong&gt;成就感&lt;/strong&gt;和&lt;strong&gt;市場價值&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="價值觀意義方向感"&gt;價值觀（意義、方向感）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;價值觀是「最重視」、「不可妥協」的信念。你的工作想要對世界產生什麼「影響」？&lt;/li&gt;
&lt;li&gt;決定&lt;strong&gt;方向&lt;/strong&gt;和&lt;strong&gt;滿足感&lt;/strong&gt;，使工作不再只是工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在盤點完自己後，找到這三者交集的地方，那就是屬於你的「天職方向」，&lt;br&gt;
接著就可以畫出一張簡易的天職地圖，去「試玩」。&lt;br&gt;
如果發現走到最後與理想不符合、太痛苦、不喜歡，那就換一條路，再畫一張地圖去試試看。&lt;br&gt;
&lt;strong&gt;人生不是只有一次選擇，而是無數次微調的疊&lt;/strong&gt;。&lt;br&gt;
整體來說，這本書更像是一本&lt;strong&gt;心理導向的職涯地圖&lt;/strong&gt;，&lt;br&gt;
它不只告訴你外在有什麼機會，更重要的是讓你重新摸到自己的內在動力。&lt;/p&gt;
&lt;h2 id="３-actions"&gt;３ Actions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重新整理我的「強項清單」&lt;/strong&gt;&lt;br&gt;
我依照書中的方法寫下了我許多的特質，並觀察其中共通點。結果我發現自己真正的強項在於「整理複雜資訊」與「用故事啟發他人」，這讓我理解自己真正的價值不是技能，而是我「怎麼做事情」。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;設定一個「試玩型目標」&lt;/strong&gt;&lt;br&gt;
放下過去「一年三大目標」、「三年計畫」這種遠大理想的焦慮，我開始用「30天嘗試」取代長遠規劃，&lt;br&gt;
比起問「這是不是我這一輩子的道路？」，我選擇以「我用30天試試這樣完成這個小目標如何？」來減輕對於目標達成的緊繃感。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每天為「價值觀」充電&lt;/strong&gt;&lt;br&gt;
價值觀是我內在的定海神針。我每天花 5 分鐘思考並寫下：「我今天的行動，是否體現我現在最重要的價值觀（例如：健康、幫助他人、自我覺察）？」這讓我的生活不再只是代辦事項堆疊，而是與內心保持一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="finally"&gt;Finally&lt;/h2&gt;
&lt;p&gt;這本書最適合閱讀的時機，是當你感到「停滯」卻又「不甘於現狀」的時候。這本書不是教你如何立刻成功，而是幫你重新校正人生方向，讓你對於自己的擁有的特徵有了更清晰的了解。&lt;/p&gt;
&lt;p&gt;《天職地圖》不只是一本職涯書，而是一面鏡子。&lt;br&gt;
它讓我們重新看見自己天生就有的力量，並提醒：找到天職，不是要變成別人，而是成為更完整的自己。讓自己的特質在對的情境被看見、被使用、被放大。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.14 啟動協作：git fork 與 git clone 的差異</title><link>https://echoHaku.github.io/posts/post_git_16/</link><pubDate>Thu, 20 Nov 2025 09:16:19 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_16/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_15/"&gt;Git 系列分享 - p.13 遠端協作的橋樑：&lt;code&gt;git remote&lt;/code&gt;、&lt;code&gt;git pull&lt;/code&gt; 與 &lt;code&gt;git push&lt;/code&gt;&lt;/a&gt;中，我們學會了如何使用 &lt;code&gt;git remote&lt;/code&gt;、&lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt; 在本地和遠端倉庫之間傳輸變更。&lt;/p&gt;
&lt;p&gt;今天我們將回到起點，探討在開始任何協作之前，取得專案程式碼的兩種最主要方式：&lt;strong&gt;&lt;code&gt;git clone&lt;/code&gt;&lt;/strong&gt; 與 &lt;strong&gt;&lt;code&gt;git fork&lt;/code&gt;&lt;/strong&gt;。許多初學者常將兩者混淆，但它們的作用層次和目的截然不同。&lt;/p&gt;
&lt;h3 id="一git-clone遠端倉庫的本地副本"&gt;一、&lt;code&gt;git clone&lt;/code&gt;：遠端倉庫的「本地副本」&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git clone&lt;/code&gt; 是最直接的 Git 指令，它的任務只有一個： &lt;strong&gt;把遠端的整個 Git 倉庫完整下載到你的本地電腦。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="1-定義"&gt;1. 定義&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone&lt;/code&gt; 會把遠端倉庫的 &lt;strong&gt;所有分支、所有 Commit、所有歷史紀錄&lt;/strong&gt; 完整複製到本地，並建立對應的工作目錄。&lt;/li&gt;
&lt;li&gt;執行後，Git 會自動替你設定一個名為 &lt;strong&gt;&lt;code&gt;origin&lt;/code&gt;&lt;/strong&gt; 的遠端連結，指向你 clone 的來源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-發生情境與指令"&gt;2. 發生情境與指令&lt;/h4&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;情境&lt;/th&gt;
 &lt;th&gt;作用說明&lt;/th&gt;
 &lt;th&gt;範例指令&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;首次取得專案&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;第一次開始一個新專案，需要將程式碼抓到本地電腦上。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;git clone https://github.com/user/project.git&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;團隊內部協作&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;你在一個有寫入權限的團隊專案中工作。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;git clone git@github.com:team/project.git&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;查看遠端連結&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;clone 後，Git 已自動配置好 &lt;code&gt;origin&lt;/code&gt;。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;git remote -v&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="二git-fork"&gt;二、&lt;code&gt;git fork&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git fork&lt;/code&gt; &lt;strong&gt;不是一個 Git 指令&lt;/strong&gt;，而是 GitHub、GitLab 等&lt;strong&gt;遠端代管服務&lt;/strong&gt;提供的功能。它的目的是在伺服器上（例如 GitHub 網站）創建一個&lt;strong&gt;與原倉庫完全獨立的副本&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.13 遠端協作的橋樑：`git remote`、`git pull` 與 `git push`</title><link>https://echoHaku.github.io/posts/post_git_15/</link><pubDate>Wed, 19 Nov 2025 08:58:13 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_15/</guid><description>&lt;p&gt;經過前面幾篇的學習，我們已經掌握了在&lt;strong&gt;本地倉庫&lt;/strong&gt;中管理歷史、分支和 Commit 的各種技巧。然而，Git 的真正強大之處在於其&lt;strong&gt;分散式&lt;/strong&gt;的特性，讓多人可以在不同的地方安全地協作。&lt;/p&gt;
&lt;p&gt;今天，我們將探討如何將本地的成果與 GitHub、GitLab 或 Bitbucket 等&lt;strong&gt;遠端倉庫&lt;/strong&gt;（Remote Repository）進行同步。這一切都圍繞著三個核心指令：&lt;code&gt;git remote&lt;/code&gt;、&lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="一git-remote"&gt;一、&lt;code&gt;git remote&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git remote&lt;/code&gt; 指令負責管理你的本地 Git 倉庫所認識的遠端 URL 與其「短名」。&lt;/p&gt;
&lt;h4 id="1-什麼是-remote"&gt;1. 什麼是 Remote？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Remote（遠端）&lt;/strong&gt;：一個 Git 倉庫的 URL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shortname（短名）&lt;/strong&gt;：代表遠端 URL 的代稱，例如：&lt;code&gt;origin&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;預設名稱 &lt;code&gt;origin&lt;/code&gt;：&lt;/strong&gt; 當你使用 &lt;code&gt;git clone&lt;/code&gt; 時（這個指令會在下一篇說到，只要想像成是把遠端的東西複製到本地端就可以了），Git 會自動建立 &lt;code&gt;origin&lt;/code&gt; 指向原始來源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-常見情境與指令"&gt;2. 常見情境與指令&lt;/h4&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;指令&lt;/th&gt;
 &lt;th&gt;作用說明&lt;/th&gt;
 &lt;th&gt;範例情境&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git remote&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;列出&lt;/strong&gt;所有已配置的遠端短名。&lt;/td&gt;
 &lt;td&gt;想知道你的專案可以同步到哪些地方。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git remote -v&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;列出&lt;/strong&gt;遠端短名及其對應的 URL（含 Fetch 和 Push 網址）。&lt;/td&gt;
 &lt;td&gt;想確認 &lt;code&gt;origin&lt;/code&gt; 實際上指向哪個 GitHub 連結。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git remote add &amp;lt;name&amp;gt; &amp;lt;url&amp;gt;&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;新增&lt;/strong&gt;一個遠端倉庫。&lt;/td&gt;
 &lt;td&gt;你想將專案同時備份到 GitHub (&lt;code&gt;origin&lt;/code&gt;) 和 GitLab (&lt;code&gt;backup&lt;/code&gt;)。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git remote remove &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;刪除&lt;/strong&gt;一個遠端連接。&lt;/td&gt;
 &lt;td&gt;某個遠端倉庫不再使用或網址失效。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git remote rename &amp;lt;old&amp;gt; &amp;lt;new&amp;gt;&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;重新命名&lt;/strong&gt;遠端短名稱。&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="二git-pull從遠端下載並整合更新"&gt;二、&lt;code&gt;git pull&lt;/code&gt;：從遠端「下載並整合更新」&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt; 的功能是從遠端倉庫&lt;strong&gt;抓取&lt;/strong&gt;（Fetch）最新的變更，並將這些變更與你的&lt;strong&gt;本地工作&lt;/strong&gt;進行&lt;strong&gt;整合&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.12 歷史控制：`git reset`、`git revert` 與 `git cherry-pick`</title><link>https://echoHaku.github.io/posts/post_git_14/</link><pubDate>Tue, 18 Nov 2025 08:54:43 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_14/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_13/"&gt;Git 系列分享 - p.11 歷史重寫與整理：&lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;squash&lt;/code&gt; 的魔法&lt;/a&gt;中，我們學會了如何使用 &lt;code&gt;git rebase&lt;/code&gt; 來清理本地的 Commit 歷史。今天，我們將探討另外三個控制 Git 歷史的關鍵指令，它們分別代表了三種處理 Commit 的態度：&lt;strong&gt;破壞性撤銷、安全撤銷，以及精準複製。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="一git-reset破壞性撤銷時光倒流並撕掉頁面"&gt;一、&lt;code&gt;git reset&lt;/code&gt;：破壞性撤銷（時光倒流並撕掉頁面）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git reset&lt;/code&gt; 是一個強大的「時光機」指令，它能將你的 &lt;code&gt;HEAD&lt;/code&gt;（書籤）和當前分支指標（便利貼）&lt;strong&gt;移回&lt;/strong&gt;到歷史中的某個 Commit。&lt;/p&gt;
&lt;h4 id="1-定義與比喻"&gt;1. 定義與比喻&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定義：&lt;/strong&gt; &lt;code&gt;git reset&lt;/code&gt; 會移動 &lt;code&gt;HEAD&lt;/code&gt; 和分支指標，並根據不同的模式（&lt;code&gt;--soft&lt;/code&gt;, &lt;code&gt;--mixed&lt;/code&gt;, &lt;code&gt;--hard&lt;/code&gt;），來處理被「撤銷」 Commit 中的內容。它是一種&lt;strong&gt;破壞性操作&lt;/strong&gt;，因為它會讓後面的 Commit 看起來像是從來沒發生過。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;書籤比喻：&lt;/strong&gt; 想像你寫日記時發現寫錯了，你將&lt;strong&gt;書籤（HEAD）退回到前幾頁，並且可能將後面的頁面（Commit）全部撕掉或塗改&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-三種模式處理內容的方式"&gt;2. 三種模式（處理內容的方式）&lt;/h4&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;模式&lt;/th&gt;
 &lt;th&gt;作用於 Commit&lt;/th&gt;
 &lt;th&gt;作用於暫存區&lt;/th&gt;
 &lt;th&gt;作用於工作目錄&lt;/th&gt;
 &lt;th&gt;比喻（被撕掉頁面上的內容）&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;--soft&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;退回&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;保留&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;保留&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;內容已用原子筆寫完，但你讓書籤退回，告訴自己「這一頁不算數」，內容留在桌上。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;--mixed&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;退回&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;清除&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;保留&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;內容從原子筆稿退回成&lt;strong&gt;鉛筆草稿&lt;/strong&gt;（清除暫存區），內容留在桌上。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;&lt;code&gt;--hard&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;退回&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;清除&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;清除&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;直接撕掉頁面&lt;/strong&gt;，丟進垃圾桶（清除工作目錄和暫存區）。&lt;strong&gt;最危險，請謹慎使用！&lt;/strong&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="3-發生情境與指令"&gt;3. 發生情境與指令&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;情境：&lt;/strong&gt; 發現最新的 Commit &lt;strong&gt;寫錯了&lt;/strong&gt;，且該 Commit &lt;strong&gt;尚未推送到遠端（未共享）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令：&lt;/strong&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# 常用：撤銷最近一次 Commit，保留內容在工作目錄中繼續修改
git reset HEAD~1 

# 危險：完全拋棄最近三次 Commit 的所有內容
git reset --hard HEAD~3 

# 撤銷所有暫存區內容，回到工作目錄（清除鉛筆稿，保留內容在紙上）
git reset HEAD &amp;lt;file&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="二git-revert安全撤銷承認錯誤並寫一篇新的日記"&gt;二、&lt;code&gt;git revert&lt;/code&gt;：安全撤銷（承認錯誤並寫一篇新的日記）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt; 是一種&lt;strong&gt;非破壞性&lt;/strong&gt;的撤銷方式。它不會移動 &lt;code&gt;HEAD&lt;/code&gt; 或刪除任何 Commit，而是透過新增一個 Commit 來&lt;strong&gt;抵銷&lt;/strong&gt;歷史中的某個變更。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.11 歷史重寫與整理：`git rebase` 和 `squash` 的魔法</title><link>https://echoHaku.github.io/posts/post_git_13/</link><pubDate>Thu, 13 Nov 2025 08:39:49 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_13/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_12/"&gt;Git 系列分享 - p.10 整合工作線：&lt;code&gt;git merge&lt;/code&gt; 的兩種策略與原理&lt;/a&gt;中，我們確認了 &lt;code&gt;git merge&lt;/code&gt; 是將分散的工作線安全整合回主線的最佳且非破壞性（Non-destructive）的方式。
然而，Git 還有另一種強大的工具，它可以讓你的歷史紀錄看起來像一條筆直的直線、乾淨無比。這個工具就是 &lt;strong&gt;&lt;code&gt;git rebase&lt;/code&gt;&lt;/strong&gt;（歷史重寫）。
Rebase 並非用來「合併」 Commit，而是用來「&lt;strong&gt;移動&lt;/strong&gt;」或「&lt;strong&gt;重新編排&lt;/strong&gt;」 Commit 的歷史。&lt;/p&gt;
&lt;h3 id="一git-rebase歷史線的搬家與重寫工程"&gt;一、&lt;code&gt;git rebase&lt;/code&gt;：歷史線的「搬家與重寫」工程&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt; 顧名思義就是 &lt;strong&gt;Re-base&lt;/strong&gt;，改變分支的基礎（Base）。它的核心目的，是讓你的分支看起來像是從目標分支的&lt;strong&gt;最新 Commit 之後才開始開發的&lt;/strong&gt;。（也就是你的修改會在原分支的最後）&lt;/p&gt;
&lt;h4 id="1-rebase-的原理與比喻"&gt;1. Rebase 的原理與比喻&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比喻：&lt;/strong&gt; 想像你有一張藍色便利貼（&lt;code&gt;feature&lt;/code&gt; 分支），它本來貼在日記的第 5 頁（舊 Commit）。現在，主線（&lt;code&gt;main&lt;/code&gt;）日記已經寫到了第 10 頁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Merge 的做法：&lt;/strong&gt; 產生一張「合併」頁面（第 11 頁），同時指著第 10 頁和藍色便利貼。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rebase 的做法：&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;拆下：&lt;/strong&gt; 把藍色便利貼上的內容（你的 Commit 紀錄）&lt;strong&gt;暫時拆下來&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重抄：&lt;/strong&gt; 把這些內容&lt;strong&gt;一頁一頁地&lt;/strong&gt;，按照順序重新抄寫到日記本的最新頁面（第 10 頁）後面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移動：&lt;/strong&gt; 藍色便利貼（&lt;code&gt;feature&lt;/code&gt; 指標）現在貼在新的第 13 頁（新的 Commit）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;結果：&lt;/strong&gt; 你的 &lt;code&gt;feature&lt;/code&gt; 分支看起來是從第 10 頁直接往後接的，歷史記錄變成一條筆直的直線。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-rebase-的核心差異重寫歷史"&gt;2. Rebase 的核心差異：重寫歷史&lt;/h4&gt;
&lt;p&gt;Rebase 在重抄 Commit 內容時，會產生&lt;strong&gt;全新的 Commit SHA 雜湊值&lt;/strong&gt;（即新的版本編號）。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.10 整合工作線：`git merge` 的兩種策略與原理</title><link>https://echoHaku.github.io/posts/post_git_12/</link><pubDate>Wed, 12 Nov 2025 08:57:17 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_12/</guid><description>&lt;p&gt;在 &lt;a href="https://echoHaku.github.io/posts/post_git_11/"&gt;Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD&lt;/a&gt; 中，我們學會了如何使用分支來安全地隔離工作。現在，當你在 &lt;code&gt;feature&lt;/code&gt; 分支上的新功能開發完成後，我們就需要將它與主線（&lt;code&gt;main&lt;/code&gt; 分支）的工作&lt;strong&gt;整合&lt;/strong&gt;在一起。&lt;/p&gt;
&lt;p&gt;這個「整合」的動作，就是由 &lt;strong&gt;&lt;code&gt;git merge&lt;/code&gt;&lt;/strong&gt; 指令來完成的。&lt;/p&gt;
&lt;h3 id="一git-merge-的目的將分散的工作線匯集"&gt;一、&lt;code&gt;git merge&lt;/code&gt; 的目的：將分散的工作線匯集&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 的核心目的只有一個：將目標分支（通常是你的新功能分支）的歷史紀錄，融合到當前你所在的分支（通常是主線 &lt;code&gt;main&lt;/code&gt;）中。&lt;/p&gt;
&lt;p&gt;在執行合併前，你必須先用 &lt;code&gt;git switch&lt;/code&gt; &lt;strong&gt;切換到「接收變更」的分支&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# 假設要將 feature/login 合併到 main 
git switch main # 1. 確保 HEAD 在接收變更的分支上 (main)
git merge feature/login # 2. 執行合併，目標分支為 feature/login
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根據兩個分支的歷史關係，&lt;code&gt;git merge&lt;/code&gt; 會自動採用以下兩種主要策略之一：&lt;/p&gt;
&lt;h3 id="二策略一fast-forward-快轉合併"&gt;二、策略一：Fast-Forward (快轉合併)&lt;/h3&gt;
&lt;p&gt;如果目標分支（&lt;code&gt;feature&lt;/code&gt;）是從當前分支（&lt;code&gt;main&lt;/code&gt;）的最新 Commit 之後開始開發，並且 &lt;code&gt;main&lt;/code&gt; 分支在 &lt;code&gt;feature&lt;/code&gt; 分支開發期間&lt;strong&gt;沒有任何新的 Commit&lt;/strong&gt;，Git 就會採用 Fast-Forward 策略。&lt;/p&gt;
&lt;h4 id="1-合併原理"&gt;1. 合併原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比喻：&lt;/strong&gt; 就像你在交換日記中新增了一頁內容，但中間沒有任何人寫過。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;動作：&lt;/strong&gt; Git 不會產生新的 Commit。它只會將 &lt;code&gt;main&lt;/code&gt; 分支的指標（便利貼）&lt;strong&gt;直接移動&lt;/strong&gt;到 &lt;code&gt;feature&lt;/code&gt; 分支的最新 Commit 上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;結果：&lt;/strong&gt; 分支歷史呈現一條直線，非常簡潔。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-優缺點與情境"&gt;2. 優缺點與情境&lt;/h4&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;項目&lt;/th&gt;
 &lt;th&gt;說明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;優點&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;歷史線最乾淨，沒有多餘的 Commit 節點。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;缺點&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;會遺失分支資訊&lt;/strong&gt;：一旦合併，你看 &lt;code&gt;git log&lt;/code&gt; 時，會看不出來這些 Commit 是屬於哪個 &lt;code&gt;feature&lt;/code&gt; 分支的工作。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;情境&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;適用於短暫、單一目標的分支，且你不介意失去「分支記錄」時。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="三策略二three-way-merge-三方合併非快轉"&gt;三、策略二：Three-way Merge (三方合併/非快轉)&lt;/h3&gt;
&lt;p&gt;如果當前分支（&lt;code&gt;main&lt;/code&gt;）在你開發 &lt;code&gt;feature&lt;/code&gt; 分支的期間，也&lt;strong&gt;有了新的 Commit&lt;/strong&gt;（例如其他人提交的 Hotfix），那麼兩個分支的歷史就會產生分岔。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD</title><link>https://echoHaku.github.io/posts/post_git_11/</link><pubDate>Fri, 07 Nov 2025 09:02:53 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_11/</guid><description>&lt;p&gt;在 &lt;a href="https://echoHaku.github.io/posts/post_git_10/"&gt;Git 系列分享 - p.8 Git 的核心力量 - 分支 (Branch)&lt;/a&gt; 中，我們學會了使用分支（Branch）來隔離工作，並用「多人交換日記」的比喻來理解 Git 的核心概念。
在那篇比喻中，我們提到了 &lt;code&gt;HEAD&lt;/code&gt; 就像是你的「&lt;strong&gt;書籤&lt;/strong&gt;」，它永遠指向你當前正在工作的位置。
今天，我們就要深入探討 &lt;code&gt;HEAD&lt;/code&gt; 到底是什麼，以及當這個「書籤」沒有插在「便利貼」（分支）上時，會發生什麼事？這就是所謂的 &lt;strong&gt;&lt;code&gt;DETACHED HEAD&lt;/code&gt;（分離頭部）&lt;/strong&gt; 狀態。&lt;/p&gt;
&lt;h3 id="一head你的書籤當前工作位置"&gt;一、&lt;code&gt;HEAD&lt;/code&gt;：你的「書籤」（當前工作位置）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt; 是 Git 中一個非常特殊的指標（Pointer），它只有一個任務：&lt;strong&gt;永遠指向你目前所在的位置&lt;/strong&gt;。
&lt;code&gt;HEAD&lt;/code&gt; 的狀態決定了你的下一個 Commit 會被建立在哪裡。&lt;/p&gt;
&lt;h4 id="1-正常的-headattached-head"&gt;1. 正常的 &lt;code&gt;HEAD&lt;/code&gt;（Attached HEAD）&lt;/h4&gt;
&lt;p&gt;在 99% 的情況下，&lt;code&gt;HEAD&lt;/code&gt; 會指向一個&lt;strong&gt;分支名稱&lt;/strong&gt;（例如 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;feat/featA&lt;/code&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;運作方式：&lt;/strong&gt; &lt;code&gt;HEAD&lt;/code&gt; → &lt;code&gt;main&lt;/code&gt; → &lt;code&gt;Commit_C&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比喻：&lt;/strong&gt; 你的「書籤」（&lt;code&gt;HEAD&lt;/code&gt;）插在「藍色便利貼」（&lt;code&gt;main&lt;/code&gt; 分支）上，而這張便利貼貼在日記的「第 C 頁」（&lt;code&gt;Commit_C&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;結果：&lt;/strong&gt; 當你寫下新的一頁（&lt;code&gt;Commit_D&lt;/code&gt;）時，你的書籤和藍色便利貼會一起移動到 &lt;code&gt;Commit_D&lt;/code&gt;。這是最安全且正常的狀態。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-head-相關指令"&gt;2. &lt;code&gt;HEAD&lt;/code&gt; 相關指令&lt;/h4&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;指令&lt;/th&gt;
 &lt;th&gt;作用說明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;會在第一行顯示 &lt;code&gt;On branch &amp;lt;branch-name&amp;gt;&lt;/code&gt;，告訴你 &lt;code&gt;HEAD&lt;/code&gt; 目前附著在哪個分支上。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git branch&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;當前 &lt;code&gt;HEAD&lt;/code&gt; 所在的分支會以 &lt;code&gt;*&lt;/code&gt; 號標記。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;會用 &lt;code&gt;(HEAD -&amp;gt; &amp;lt;branch-name&amp;gt;)&lt;/code&gt; 標示出 &lt;code&gt;HEAD&lt;/code&gt; 的位置。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;cat .git/HEAD&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;(進階)&lt;/strong&gt; 直接查看 &lt;code&gt;.git&lt;/code&gt; 資料夾中的 &lt;code&gt;HEAD&lt;/code&gt; 檔案內容，你會看到 &lt;code&gt;ref: refs/heads/main&lt;/code&gt;，證明它指向一個分支。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="二detached-head分離頭部狀態"&gt;二、&lt;code&gt;DETACHED HEAD&lt;/code&gt;：分離頭部狀態&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DETACHED HEAD&lt;/code&gt; &lt;strong&gt;不是一個錯誤&lt;/strong&gt;，而是一種特殊狀態。它發生在 &lt;code&gt;HEAD&lt;/code&gt; &lt;strong&gt;不再指向分支名稱&lt;/strong&gt;，而是&lt;strong&gt;直接指向某一個特定的 Commit SHA-1 雜湊值&lt;/strong&gt;時。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.7 版本控制的篩選器 - .gitignore 的使用與規則</title><link>https://echoHaku.github.io/posts/post_git_9/</link><pubDate>Thu, 23 Oct 2025 08:54:10 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_9/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_8/"&gt;Git 系列分享 - p.6 正式提交一個commit囉&lt;/a&gt;中，我們學會了如何使用 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 為專案建立乾淨且有意義的歷史紀錄。&lt;/p&gt;
&lt;p&gt;然而，在你的專案資料夾中，總是會存在一些你&lt;strong&gt;不希望&lt;/strong&gt;被 Git 納入追蹤、也不想提交到版本庫的檔案。這些檔案會不斷被 &lt;code&gt;git status&lt;/code&gt; 標記為 &lt;code&gt;Untracked files&lt;/code&gt;，造成混亂。這時，我們就需要版本控制的篩選器：&lt;strong&gt;&lt;code&gt;.gitignore&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="一gitignore使用情境與目的"&gt;一、&lt;code&gt;.gitignore&lt;/code&gt;：使用情境與目的&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; 是一個簡單的純文字檔案，它告訴 Git &lt;strong&gt;應該忽略哪些檔案和資料夾&lt;/strong&gt;。它的目的在於：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;目的&lt;/th&gt;
 &lt;th&gt;說明&lt;/th&gt;
 &lt;th&gt;檔案範例&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;保護隱私&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;環境變數檔通常包含 API Key、密碼等敏感資訊，必須阻止其上傳。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;.env&lt;/code&gt;, &lt;code&gt;config.local&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;避免冗餘&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;編譯產生的檔案或大型函式庫可以隨時重新生成，不應浪費空間納入版本庫。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;*.exe&lt;/code&gt;, &lt;code&gt;*.log&lt;/code&gt;, &lt;code&gt;node_modules/&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;保持乾淨&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;忽略個人編輯器或作業系統產生的暫存檔，讓團隊成員之間不受彼此環境的干擾。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;.vscode/&lt;/code&gt;, &lt;code&gt;.DS_Store&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="二如何建立與添加規則"&gt;二、如何建立與添加規則？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; 檔案必須建立在你的&lt;strong&gt;專案根目錄&lt;/strong&gt;下，這樣 Git 才能在專案的任何地方套用這些規則。建立後，&lt;strong&gt;記得將 &lt;code&gt;.gitignore&lt;/code&gt; 本身加入 Git 追蹤&lt;/strong&gt;，以便團隊成員共享規則。&lt;/p&gt;
&lt;h3 id="1-命令列-cli-執行"&gt;1. 命令列 (CLI) 執行&lt;/h3&gt;
&lt;p&gt;在專案根目錄下，你可以使用指令直接建立這個檔案並寫入內容：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# 建立一個名為 .gitignore 的檔案
touch .gitignore

# 編輯檔案，例如加入規則：
echo &amp;#34;node_modules/&amp;#34; &amp;gt;&amp;gt; .gitignore
echo &amp;#34;*.log&amp;#34; &amp;gt;&amp;gt; .gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是直接建立完檔案後，將&lt;code&gt;.gitignore&lt;/code&gt; 檔案加入 Git 即可。&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.8 Git 的核心力量 - 分支 (Branch)</title><link>https://echoHaku.github.io/posts/post_git_10/</link><pubDate>Thu, 23 Oct 2025 08:54:10 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_10/</guid><description>&lt;p&gt;在了解&lt;a href="https://echoHaku.github.io/posts/post_git_9/"&gt;Git 系列分享 - p.7 版本控制的篩選器 - .gitignore 的使用與規則&lt;/a&gt;之後，其實你已經可以掌握了Git的基礎單人工作流程了！然而，Git 之所以能成為團隊協作的標準工具，全賴於它最核心且強大的功能：&lt;strong&gt;分支（Branch）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="一git-branch-的概念什麼是分支"&gt;一、&lt;code&gt;git branch&lt;/code&gt; 的概念：什麼是分支？&lt;/h2&gt;
&lt;p&gt;分支的目的是什麼呢？分支的核心目的是為了解決&lt;strong&gt;同時進行多項修改時互相干擾的問題&lt;/strong&gt;，確保主線版本是穩定的。&lt;/p&gt;
&lt;p&gt;在傳統世界裡，要想實現分支的概念，可能意味著要複製整個專案資料到另一資料夾上，大家都有這個經歷吧，複製整個專案會花大量的時間，又佔用大量的空間。相較之下，在 Git 的世界裡，分支並不像傳統版本控制系統那樣複雜或佔用大量資源，為什麼呢？&lt;/p&gt;
&lt;h3 id="1-分支是一個輕量級的指標"&gt;1. 分支是一個輕量級的「指標」&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本質：&lt;/strong&gt; 分支不是一個資料夾的完整複製，它只是一個&lt;strong&gt;可移動的指標（Pointer）&lt;/strong&gt;，指向某一個特定的 Commit 紀錄。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Branch&lt;/code&gt; 通常會貼在該分支最新的commit上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;預設分支：&lt;/strong&gt; 當你執行 &lt;code&gt;git init&lt;/code&gt; 時，Git 會自動建立第一個分支，通常是 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;master&lt;/code&gt;，它指向你的第一次 Commit。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;運作原理：&lt;/strong&gt; 由於分支只是一個指標，所以建立、切換、刪除分支的操作都極為快速，幾乎是瞬間完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-head-是你的當前位置"&gt;2. &lt;code&gt;HEAD&lt;/code&gt; 是你的「當前位置」&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HEAD&lt;/code&gt;：&lt;/strong&gt; &lt;code&gt;HEAD&lt;/code&gt; 是一個特殊的指標，它永遠指向你&lt;strong&gt;目前正在工作的分支&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; HEAD 指示了下一個 Commit 應該被建立在何處。當新的 Commit 產生時，HEAD 和當前分支指標都會跟著前進。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;檢視：&lt;/strong&gt; 當你輸入 &lt;code&gt;git log&lt;/code&gt; 時，你會看到 &lt;code&gt;HEAD -&amp;gt; main&lt;/code&gt;，表示你目前位於 &lt;code&gt;main&lt;/code&gt; 分支上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="二分支的使用情境為何需要分支"&gt;二、分支的使用情境：為何需要分支？&lt;/h3&gt;
&lt;p&gt;分支最大的價值在於「&lt;strong&gt;隔離工作&lt;/strong&gt;」，讓我們在不影響主線程式碼的條件下，安全地進行開發、測試或實驗。&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;情境&lt;/th&gt;
 &lt;th&gt;分支名稱建議&lt;/th&gt;
 &lt;th&gt;目的&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;開發新功能&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;feature/&amp;lt;功能名稱&amp;gt;&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;在獨立的環境下開發完整功能，避免半成品影響到主線（&lt;code&gt;main&lt;/code&gt;）穩定版本。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;緊急修正 Bug&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;hotfix/&amp;lt;問題描述&amp;gt;&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;快速從主線拉出一個分支來修復 Bug，修復完成後馬上合併回主線並發布。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;試驗性代碼&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;experiment/&amp;lt;主題&amp;gt;&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;測試一些可能失敗的程式碼或新技術，失敗後可以直接丟棄整個分支，不留痕跡。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;多人協作&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;user/&amp;lt;使用者名稱&amp;gt;&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;團隊成員各自擁有自己的分支來進行開發，減少互相干擾和不必要的衝突。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="三git-核心概念的交換日記比喻"&gt;三、Git 核心概念的「交換日記」比喻&lt;/h3&gt;
&lt;p&gt;我想了很久要用什麼比喻讓大家可以快速理解Git的這些核心元素，最後我認為比較淺顯的方式可能是用「交換日記」來模擬！我們可以將整個版本控制過程想像成一份持續更新的&lt;strong&gt;日記本&lt;/strong&gt;：&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.6 正式提交一個commit囉</title><link>https://echoHaku.github.io/posts/post_git_8/</link><pubDate>Wed, 22 Oct 2025 09:24:01 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_8/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_7/"&gt;Git 系列分享 - p.5 檔案追蹤並納入紀錄！（git status、git add）&lt;/a&gt;中，我們學會了如何使用 &lt;code&gt;git add&lt;/code&gt; 將變更從工作目錄移動到暫存區（Staging Area），完成變更的打包。&lt;/p&gt;
&lt;p&gt;現在，我們將進行工作流程中的最後一步：&lt;strong&gt;正式提交（Commit）&lt;/strong&gt;，為這次變更留下一個永久且不可磨滅的歷史快照。&lt;/p&gt;
&lt;h2 id="git-commit為變更留下永久快照"&gt;&lt;code&gt;git commit&lt;/code&gt;：為變更留下永久快照&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt; 是 Git 流程中&lt;strong&gt;最關鍵的動作&lt;/strong&gt;。它會將暫存區的快照&lt;strong&gt;永久寫入&lt;/strong&gt;你的 Git 倉庫 (Repository)，形成專案歷史上的一個&lt;strong&gt;新版本節點&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="什麼是一個-commit"&gt;什麼是一個 Commit？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定義：&lt;/strong&gt; 一個 Commit 就是一個「&lt;strong&gt;有意義的、邏輯完整的工作單元&lt;/strong&gt;」。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;劃分原則：&lt;/strong&gt; 我們應該以「目的」來劃分 Commit，而不是以「時間」。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重點強調：&lt;/strong&gt; Commit 的大小並不重要！它可以是一個&lt;strong&gt;微小的 Bug 修正（小版本）&lt;/strong&gt;，也可以是一個&lt;strong&gt;完整的核心功能開發（大版本）&lt;/strong&gt;。關鍵在於：這個 Commit 必須只包含&lt;strong&gt;單一目的的變更&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;好的 Commit：&lt;/strong&gt; 專注於單一目標。例如：「修正使用者登入頁面的 CSS 樣式」或「新增資料庫連線功能」。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不好的 Commit：&lt;/strong&gt; 包含了不相關的變更。例如：「修正 Bug + 調整排版 + 實驗性新功能」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重要性：&lt;/strong&gt; 當你確定暫存區的變更已經完成了一個&lt;strong&gt;獨立的任務&lt;/strong&gt;時，才應該執行 Commit。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="commit-message-的重要性"&gt;Commit Message 的重要性&lt;/h2&gt;
&lt;p&gt;Commit Message 就像是這個版本變動的「&lt;strong&gt;摘要與目的&lt;/strong&gt;」，它是版本歷史中最重要的註解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;給未來的自己看：&lt;/strong&gt; 當幾個月後，你需要追溯某個功能或 Bug 的來源時，清晰的訊息能讓你快速定位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;給團隊成員看：&lt;/strong&gt; 隊友能透過訊息快速了解你做了什麼，避免重複工作或產生衝突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;💡 優秀的 Commit Message 寫法建議：&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.5 檔案追蹤並納入紀錄！（git status、git add）</title><link>https://echoHaku.github.io/posts/post_git_7/</link><pubDate>Thu, 16 Oct 2025 09:57:53 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_7/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_6/"&gt;Git 系列分享 - p.4 你是誰？git config 的配置與層級&lt;/a&gt;完成身分設定後，&lt;br&gt;
我們就要進入Git的核心工作流程了！&lt;br&gt;
今天的主題圍繞在「&lt;strong&gt;追蹤變動&lt;/strong&gt;」與「&lt;strong&gt;將變動納入下一個版本&lt;/strong&gt;」的過程。&lt;/p&gt;
&lt;h2 id="一git-status專案的狀態報告"&gt;一、&lt;code&gt;git status&lt;/code&gt;：專案的狀態報告&lt;/h2&gt;
&lt;p&gt;還記得我們在 &lt;a href="https://echoHaku.github.io/posts/post_git_4/"&gt;Git 系列分享 - p.2 Git 對於修改的文件是怎麼劃分的呢？&lt;/a&gt; 所提到的三個工作區域嗎？&lt;br&gt;
&lt;code&gt;git status&lt;/code&gt; 這個指令就是你的「&lt;strong&gt;工作區偵測器&lt;/strong&gt;」，它會掃描你的工作目錄（Working Directory，也就是實體資料夾裡的檔案們），並與 Git 倉庫中的最新版本進行比對，從而確定檔案的狀態：
&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;檔案狀態&lt;/th&gt;
 &lt;th&gt;所在區域&lt;/th&gt;
 &lt;th&gt;顯示於 &lt;code&gt;git status&lt;/code&gt;&lt;/th&gt;
 &lt;th&gt;須進行的操作&lt;/th&gt;
 &lt;th&gt;視覺化工具顯示（Sourcetree）&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;Untracked&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;工作目錄&lt;/td&gt;
 &lt;td&gt;紅色 (Untracked files)&lt;/td&gt;
 &lt;td&gt;需要 &lt;code&gt;git add&lt;/code&gt; 納入追蹤&lt;/td&gt;
 &lt;td&gt;Unstaged Files&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;Modified&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;工作目錄&lt;/td&gt;
 &lt;td&gt;紅色 (Changes not staged for commit)&lt;/td&gt;
 &lt;td&gt;需要 &lt;code&gt;git add&lt;/code&gt; 更新暫存區&lt;/td&gt;
 &lt;td&gt;Unstaged Files&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;Staged&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;暫存區&lt;/td&gt;
 &lt;td&gt;綠色 (Changes to be committed)&lt;/td&gt;
 &lt;td&gt;可以 &lt;code&gt;git commit&lt;/code&gt; 正式提交&lt;/td&gt;
 &lt;td&gt;Staged Files&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;Unmodified&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;Git 倉庫&lt;/td&gt;
 &lt;td&gt;不顯示（乾淨狀態）&lt;/td&gt;
 &lt;td&gt;無需任何操作&lt;/td&gt;
 &lt;td&gt;不顯示&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;當你打開終端機輸入 &lt;code&gt;git status&lt;/code&gt; 時，它會清楚地告訴你：&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.4 你是誰？git config 的配置與層級</title><link>https://echoHaku.github.io/posts/post_git_6/</link><pubDate>Mon, 13 Oct 2025 09:09:25 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_6/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_5/"&gt;Git 系列分享 - p.3 第一次使用 Git：專案初始化 git init&lt;/a&gt; 之後，我們已經成功讓 Git 接管了你的專案。然而，在開始提交 (Commit) 版本之前，Git 需要知道「你是誰」。
而&lt;code&gt;git config&lt;/code&gt; 正是用來&lt;strong&gt;設定使用者名稱、email、編輯器、顯示風格&lt;/strong&gt;等參數的工具。這些參數將決定每一次版本紀錄（Commit）時，是誰完成了這項工作。&lt;/p&gt;
&lt;h3 id="一為什麼要設定-git-config必備設定"&gt;一、為什麼要設定 &lt;code&gt;git config&lt;/code&gt;？（必備設定）&lt;/h3&gt;
&lt;p&gt;Git 必須將你的身份資訊附加到每一個提交記錄中，以確保版本歷史可被追溯。以下兩個參數是&lt;strong&gt;最基本且必須設定&lt;/strong&gt;的：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;參數&lt;/th&gt;
 &lt;th&gt;用途說明&lt;/th&gt;
 &lt;th&gt;範例指令&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;user.name&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;設定提交記錄上顯示的「使用者名稱」。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;git config --global user.name &amp;quot;Your Name&amp;quot;&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;user.email&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;設定提交記錄上顯示的「電子郵件」。&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;git config --global user.email &amp;quot;your.email@example.com&amp;quot;&lt;/code&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="二認識-git-配置的三個層級"&gt;二、認識 Git 配置的三個層級&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; 的設定可以劃分為三個層級（作用域），它們決定了配置的適用範圍，並且有&lt;strong&gt;層級優先順序&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;System（系統層級）
&lt;ul&gt;
&lt;li&gt;適用於整台電腦的所有使用者。&lt;/li&gt;
&lt;li&gt;設定檔位置：git 安裝的資料夾裡，Linux: &lt;code&gt;/etc/gitconfig&lt;/code&gt;，Windows: &lt;code&gt;C:\ProgramData\Git\config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指令加上：&lt;code&gt;--system&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;優先級最低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Global（使用者層級）&lt;/strong&gt; ✅ 最常用
&lt;ul&gt;
&lt;li&gt;適用於當前作業系統帳號的所有 Git 倉庫。&lt;/li&gt;
&lt;li&gt;設定檔位置：電腦登入帳號的目錄底下，Linux: &lt;code&gt;~/.gitconfig&lt;/code&gt;，Windows:&lt;code&gt;C:\User\&amp;lt;帳號&amp;gt;\.gitconfig&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指令加上：&lt;code&gt;--global&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;優先級中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Local（倉庫層級）
&lt;ul&gt;
&lt;li&gt;僅適用於特定的 Git 倉庫。通常是因為有多個帳號（公司用、個人用），所以在個別倉庫去指定用哪個帳號。&lt;/li&gt;
&lt;li&gt;設定檔位置：每個.git資料夾內&lt;code&gt;.git/config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;預設為 local scope，如果不指定 &lt;code&gt;--global&lt;/code&gt; 或 &lt;code&gt;--system&lt;/code&gt;，就會套用在這裡，或是用&lt;code&gt;--local&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;優先級最高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;優先順序與應用情境&lt;/strong&gt;&lt;br&gt;
Git 會依據 &lt;strong&gt;Local → Global → System&lt;/strong&gt; 的順序來讀取設定。&lt;br&gt;
例如，如果你在 Global 層級設定了個人 Email，但在某個專案（Local 層級）設定了公司 Email，則該專案會&lt;strong&gt;優先使用&lt;/strong&gt; Local 層級設定的公司 Email。&lt;br&gt;
這樣可以讓你在一台電腦同時去使用兩組或以上的git設定！&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.3 第一次使用 Git：專案初始化 git init</title><link>https://echoHaku.github.io/posts/post_git_5/</link><pubDate>Wed, 08 Oct 2025 09:11:34 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_5/</guid><description>&lt;p&gt;在&lt;a href="https://echoHaku.github.io/posts/post_git_4/"&gt;Git 系列分享 - p.2 Git 對於修改的文件是怎麼劃分的呢？&lt;/a&gt; 我們了解了 Git 如何將專案劃分為工作目錄、暫存區和 Git 倉庫這三個區域。現在，讓我們開始實戰，學習如何讓 Git 開始管理你的專案！&lt;/p&gt;
&lt;h2 id="啟動版本控制git-init-的奧秘"&gt;啟動版本控制：&lt;code&gt;git init&lt;/code&gt; 的奧秘&lt;/h2&gt;
&lt;p&gt;要讓 Git 接管一個資料夾，使其具備版本控制能力，我們需要做的第一步就是&lt;strong&gt;初始化 (Initialize) 專案&lt;/strong&gt;。這個動作是透過 &lt;code&gt;git init&lt;/code&gt; 指令來完成的。&lt;/p&gt;
&lt;p&gt;當你執行 &lt;code&gt;git init&lt;/code&gt; 之後，Git 就會在這個資料夾內建立它的「資料庫」，專案才正式進入 Git 的管理流程。&lt;/p&gt;
&lt;h3 id="git-init-實際做了什麼"&gt;&lt;code&gt;git init&lt;/code&gt; 實際做了什麼？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建立核心資料庫：&lt;code&gt;.git&lt;/code&gt; 資料夾&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git 會在你的專案資料夾內建立一個&lt;strong&gt;隱藏的 &lt;code&gt;.git&lt;/code&gt; 資料夾&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;這個資料夾就是你的 &lt;strong&gt;Local Repository (本地倉庫)&lt;/strong&gt;，它包含了所有 Git 運作所需的檔案和資料結構，例如：&lt;strong&gt;所有版本紀錄 (Commit History)&lt;/strong&gt;、&lt;strong&gt;分支資訊 (Branches)&lt;/strong&gt;、配置設定、以及你之前提過的 &lt;strong&gt;暫存區 (Index)&lt;/strong&gt; 資訊等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重要性：&lt;/strong&gt; 這是 Git 儲存所有歷史快照的核心資料庫。&lt;strong&gt;請勿手動修改或刪除此資料夾內的任何檔案！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化主分支：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git 會自動建立一個預設的主線分支，傳統上稱為 &lt;code&gt;master&lt;/code&gt;，但現在許多新的 Git 版本和平台會將其預設為 &lt;strong&gt;&lt;code&gt;main&lt;/code&gt;&lt;/strong&gt;。這就是你專案的起點。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="如何執行-git-init"&gt;如何執行 &lt;code&gt;git init&lt;/code&gt;？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用命令列(CLI)執行。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;開啟終端機（Windows的cmd或git bash、macOS/Linux的 Terminal）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; 到要管理的資料夾位置&lt;/li&gt;
&lt;li&gt;輸入&lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;點下 &lt;code&gt;enter&lt;/code&gt;，你會看到類似&lt;code&gt;Initialized empty Git repository in /path/to/your/project/.git/&lt;/code&gt;的回覆，這表示 Git 已經成功初始化。
&lt;img src="https://echoHaku.github.io/images/git_init_cli.png" alt="git init cli pic"&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;視覺化工具 (GUI) 執行&lt;/strong&gt;
若你不習慣使用指令，可以透過視覺化工具來操作。這對於害怕代碼的初學者來說是非常友好的替代方案。下方以&lt;code&gt;Sourcetree&lt;/code&gt;為例&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.2 Git 對於修改的文件是怎麼劃分的呢？</title><link>https://echoHaku.github.io/posts/post_git_4/</link><pubDate>Fri, 03 Oct 2025 09:12:47 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_4/</guid><description>&lt;p&gt;如同 &lt;a href="https://echoHaku.github.io/posts/post_git_3/"&gt;Git 系列分享 - p.1 Git是什麼？&lt;/a&gt; 所述，Git 是一種強大的版本控制工具。然而，Git 並不會將你所有的修改&lt;strong&gt;自動&lt;/strong&gt;納入版本紀錄。&lt;/p&gt;
&lt;p&gt;要理解 Git 如何追蹤和儲存你的工作，必須先了解它將一個專案劃分為的&lt;strong&gt;三個核心工作區域（Three States）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="git-的三個工作區域與主要流程"&gt;Git 的三個工作區域與主要流程&lt;/h2&gt;
&lt;p&gt;Git 的版本控制流程可以被簡化為三個步驟，文件會依序在三個區域間流動：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;工作目錄 →（git add）→ 暫存區 →（git commit）→ Git 倉庫
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這三個區域代表了 Git 對你本次修改所處狀態的認定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;🗂️ Working Directory（工作目錄）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這是你&lt;strong&gt;實際進行檔案編輯&lt;/strong&gt;的地方，也是專案檔案在你的電腦上看得見的實體資料夾。&lt;/li&gt;
&lt;li&gt;狀態認定： 所有你新建立或修改過的檔案，在尚未執行 &lt;code&gt;git add&lt;/code&gt; 之前，都處於「&lt;strong&gt;未追蹤 (Untracked)&lt;/strong&gt;」或「&lt;strong&gt;已修改 (Modified)&lt;/strong&gt;」狀態。&lt;/li&gt;
&lt;li&gt;備註： 專注於你的開發與編輯，你可以隨意修改檔案而不用擔心影響正式的版本紀錄。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;📥 Staging Area（暫存區 / Index）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暫存區是 Git 在正式提交（Commit）之前，&lt;strong&gt;用來準備「快照清單」的緩衝區&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;進入方式： 使用 &lt;code&gt;git add &amp;lt;檔案名&amp;gt;&lt;/code&gt; 指令，將你在工作目錄中的特定變更納入準備清單。&lt;/li&gt;
&lt;li&gt;關鍵作用： 它是你決定「&lt;strong&gt;哪些變更要包含進下一個版本紀錄 (Commit)&lt;/strong&gt;」的地方。&lt;/li&gt;
&lt;li&gt;備註： Git 允許你只將一個檔案的&lt;strong&gt;部分內容（Stage Hunk / Stage Lines）&lt;/strong&gt; 加入暫存區，實現「&lt;em&gt;Partial Commit&lt;/em&gt;」，這對於將大改動拆分成多個邏輯清晰的小提交非常有幫助。（像是一個檔案當中的某一段、某幾行去做Commint）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🗃️ Git Repository（Git 倉庫 / HEAD）&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.1 Git是什麼？</title><link>https://echoHaku.github.io/posts/post_git_3/</link><pubDate>Wed, 01 Oct 2025 08:32:32 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_3/</guid><description>&lt;p&gt;如同&lt;a href="https://echoHaku.github.io/posts/post_git_2/"&gt;Git 系列分享 - p.0 版本控制是什麼？&lt;/a&gt;有提及的，&lt;strong&gt;Git 是一種開源的「分散式版本控制系統（DVCS）」&lt;/strong&gt;，它專門設計來高效且可靠地處理專案中檔案的每一次變動。&lt;/p&gt;
&lt;h2 id="git-的核心優勢"&gt;Git 的核心優勢&lt;/h2&gt;
&lt;p&gt;Git 之所以能在眾多版本控制工具中脫穎而出，成為現代數位工作者的標準配備，主要歸功於其以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分散式架構 (High Redundancy)：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;每個使用者都有專案完整的歷史紀錄。即使中央伺服器故障，你仍可以從任何一位使用者端恢復資料。這讓系統的&lt;strong&gt;容錯率極高&lt;/strong&gt;，能有效避免因單點故障而導致版本控制功能停擺。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快照機制 (Snapshots)：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;機制： Git 紀錄的不是「檔案的差異」，而是將整個專案的狀態拍攝「&lt;strong&gt;快照&lt;/strong&gt;」並儲存下來。(&lt;em&gt;註：這個機制非常精妙，未來有機會的話我們會用一整篇文章來深入描述！&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;優勢： 這使得版本切換和歷史紀錄查詢&lt;strong&gt;極為迅速&lt;/strong&gt;，效率遠高於傳統的集中式系統。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;開源與免費 (Free &amp;amp; Open Source)：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;任何人都可以免費使用 Git，這也是它能迅速普及的重要原因之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;強大的分支管理 (Branching)：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Git 的分支（Branch）操作非常輕便、快速且不佔資源，讓開發者可以在不影響主線的情況下，&lt;strong&gt;安全地進行功能開發或實驗&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="git-的挑戰與考量劣勢"&gt;Git 的挑戰與考量（劣勢）&lt;/h2&gt;
&lt;p&gt;雖然 Git 功能強大，但在某些情況下，它也會帶來一些挑戰：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;學習曲線陡峭：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git 的底層概念（例如：Stage, Commit, Branch, Rebase 等）相對抽象，對於初學者來說，學習門檻確實較高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不擅長處理大型二進位檔案 (Large Binary Files)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git 的快照機制是針對&lt;strong&gt;文字檔案&lt;/strong&gt;進行高效壓縮。對於大型的二進位檔案（例如：高畫質圖檔、影音檔、大型資料庫備份），Git 會完整儲存每一個版本的快照，導致版本庫（Repository）會快速膨脹，佔用大量空間，且同步速度變慢。（&lt;em&gt;解決方案：這個問題通常會透過搭配 Git LFS (Large File Storage) 等擴展工具來解決。&lt;/em&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;部分操作的破壞性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些進階操作（如 &lt;code&gt;rebase&lt;/code&gt; 或 &lt;code&gt;reset&lt;/code&gt;）雖然功能強大，但如果操作不當，可能會修改歷史紀錄，導致與團隊成員的版本衝突，甚至遺失資料，需要謹慎使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="git-的使用途徑"&gt;Git 的使用途徑&lt;/h2&gt;
&lt;p&gt;對於新手而言，Git 的學習門檻確實相對較高，這主要體現在它複雜的指令和概念上。不過，你可以選擇以下幾種方式來使用 Git：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;終端機／命令列 (Terminal / CLI)：&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Git 系列分享 - p.0 版本控制是什麼？</title><link>https://echoHaku.github.io/posts/post_git_2/</link><pubDate>Thu, 25 Sep 2025 09:21:17 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_2/</guid><description>&lt;h2 id="版本控制到底是什麼到底可以幫助我們解決什麼問題"&gt;版本控制到底是什麼？到底可以幫助我們解決什麼問題？&lt;/h2&gt;
&lt;h3 id="版本控制"&gt;「版本控制」&lt;/h3&gt;
&lt;p&gt;在正式認識進入&lt;a href="https://echoHaku.github.io/posts/post_git_1/"&gt;Git 系列文章&lt;/a&gt; 之前，我們必須先理解「&lt;strong&gt;版本控制&lt;/strong&gt;」這個核心概念。&lt;/p&gt;
&lt;p&gt;過去，當我們想備份文件或區分不同版本時，通常會建立一個新資料夾並加上日期，然後將所有檔案複製過去。但這種做法不僅會&lt;strong&gt;占用大量空間&lt;/strong&gt;，也無法&lt;strong&gt;快速看出兩個版本之間有哪些差異，更難以追蹤每次修改的目的&lt;/strong&gt;。這也就是「版本控制」誕生的原因。&lt;/p&gt;
&lt;h3 id="版本控制不只是為了工程師而生的"&gt;版本控制不只是為了工程師而生的！&lt;/h3&gt;
&lt;p&gt;很多人以為版本控制只對工程師重要，那你就錯了。&lt;/p&gt;
&lt;p&gt;想像一下，身為一個文案企劃，你正在修改一份重要文件，結果發現最新版本改得一團糟，想要回到兩天前的雛形文件，卻不知道該怎麼辦。或者你和同事共同編輯一份文件，最終發現兩人的版本內容差異太大，無法順利合併。當你與客戶討論合約內容時，雙方針對合約中的某一行內容各執己見，無法追溯歷史紀錄&amp;hellip;這些情境是不是聽起來很熟悉？&lt;/p&gt;
&lt;p&gt;不論你是工程師、設計師、小編、業務，這些問題都可能發生在你的日常工作中。&lt;strong&gt;Git 其實不只是一個程式碼的版本控制工具，它更像是一台「數位時光機」&lt;/strong&gt;，能為你處理過的任何檔案（如 Word 文件、設計稿、企劃書等）留下修改紀錄。它讓你不僅能隨時回到過去的任何一個版本，還能有效地與他人協同工作，確保檔案不會混亂。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;版本控制是一種強大的專案管理工具，它能&lt;strong&gt;比較每次版本差異&lt;/strong&gt;、&lt;strong&gt;追蹤修改依據&lt;/strong&gt;、並&lt;strong&gt;提升協作效率&lt;/strong&gt;，對於現代數位工作者而言至關重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="版本控制工具大致核心方式分成兩類"&gt;版本控制工具大致核心方式分成兩類&lt;/h3&gt;
&lt;p&gt;版本控制工具大致核心方式分成兩類：集中式的版本控制系統（Centralized Version Control Sytem）和分散式的版本控制系統（Distributed Version Control System）。
而&lt;strong&gt;Git 是其中一種實現「分散式版本控制」的工具！&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;項目&lt;/th&gt;
 &lt;th&gt;分散式版本控制（DVCS）&lt;/th&gt;
 &lt;th&gt;集中式版本控制（CVCS）&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;定義&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;每個相關使用者的電腦當中都擁有完整的檔案 Repository 副本&lt;/strong&gt;，包括所有的歷史紀錄、分支資訊、提交紀錄等等。&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;所有的檔案及版本紀錄都集中於伺服器端&lt;/strong&gt;，開發者只會擁有目前版本的「副本」，需要連線到伺服器去做大部分的操作。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;特點&lt;/td&gt;
 &lt;td&gt;架構和權限控制相對複雜一些，可以離線操作，學習門檻較高。&lt;/td&gt;
 &lt;td&gt;架構簡單，權限控制明確，資料集中，需連線伺服器才可以執行。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;版本庫位置&lt;/td&gt;
 &lt;td&gt;每個人都有完整版本庫&lt;/td&gt;
 &lt;td&gt;僅伺服器保有完整版本庫&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;離線作業&lt;/td&gt;
 &lt;td&gt;可離線 commit / 查看歷史&lt;br&gt;可離線撰寫程式、commit、切換branch&lt;/td&gt;
 &lt;td&gt;無法離線 commit / 查看歷史&lt;br&gt;可離線撰寫程式，不可commit、不可切branch&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;效能&lt;/td&gt;
 &lt;td&gt;本地操作快&lt;/td&gt;
 &lt;td&gt;須與伺服器通訊，較慢&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;分支管理&lt;/td&gt;
 &lt;td&gt;快速輕便，支援多分支協作&lt;/td&gt;
 &lt;td&gt;分支較重，複雜&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;多人開發&lt;/td&gt;
 &lt;td&gt;各自開分支，不互相干擾&lt;/td&gt;
 &lt;td&gt;在同一分支修改，容易發生衝突&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;建立分支&lt;/td&gt;
 &lt;td&gt;本地建分支，幾乎不耗資源，快速輕巧&lt;/td&gt;
 &lt;td&gt;需在伺服器上建立資料夾，操作較慢且複雜&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;merge branch&lt;/td&gt;
 &lt;td&gt;自動合併能力強，支援rebase, squash等功能&lt;/td&gt;
 &lt;td&gt;合併功能較弱，容易產生衝突或需手動處理&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;遇到合併衝突&lt;/td&gt;
 &lt;td&gt;本機解決後再 push&lt;/td&gt;
 &lt;td&gt;必須在伺服器上解決，其他人無法同時作業&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;故障容忍性&lt;/td&gt;
 &lt;td&gt;高，資料可從他人 repo 還原&lt;/td&gt;
 &lt;td&gt;低，伺服器若掛掉風險大&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;不小心刪除本地資料&lt;/td&gt;
 &lt;td&gt;可從本地 repo 恢復完整歷史&lt;/td&gt;
 &lt;td&gt;若沒 commit，無法從本地找回&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;想改寫錯誤的 commit 歷史&lt;/td&gt;
 &lt;td&gt;用 &lt;code&gt;rebase&lt;/code&gt; 或 &lt;code&gt;reset&lt;/code&gt; 彈性操作&lt;/td&gt;
 &lt;td&gt;無法重寫歷史，只能再提交一筆修正紀錄&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;誤刪主機專案資料&lt;/td&gt;
 &lt;td&gt;其他開發者的 repo 可還原&lt;/td&gt;
 &lt;td&gt;主機毀損即資料全毀（若無備份）&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;搭配 GitHub/GitLab CI/CD、自動部屬&lt;/td&gt;
 &lt;td&gt;廣泛支援，指令簡單&lt;/td&gt;
 &lt;td&gt;支援有限，需額外串接，且較少平台有支援SVN自動部屬&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;適合對象&lt;/td&gt;
 &lt;td&gt;大型團隊、開源專案、需彈性開發&lt;/td&gt;
 &lt;td&gt;小型團隊、流程單純、控管明確&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;接下來我們將仔細看看Git到底是什麼，他到底有什麼優勢讓他成為現代數位工作者必須熟知的工具？&lt;br&gt;
&lt;a href="https://echoHaku.github.io/posts/post_git_3/"&gt;Git 系列分享 - p.1 Git是什麼？&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Git 系列分享 - 重新理解版本控制的核心概念</title><link>https://echoHaku.github.io/posts/post_git_1/</link><pubDate>Thu, 25 Sep 2025 09:21:11 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_git_1/</guid><description>&lt;h2 id="git-系列分享---重新理解版本控制的核心概念"&gt;Git 系列分享 - 重新理解版本控制的核心概念&lt;/h2&gt;
&lt;p&gt;嗨，各位好。
最近在進行個人技術的深度整理與鞏固，深刻體會到「輸出」是檢驗「輸入」成效的最佳方式。秉持著這個理念，計畫未來將會陸續分享一系列關於特定技術領域的深度文章，希望能藉此有更深度的思考與更完整的融合知識！&lt;/p&gt;
&lt;p&gt;經過審慎思考，我將第一個主題定為 &lt;strong&gt;Git&lt;/strong&gt;。作為現代軟體開發不可或缺的版本控制系統，Git 的重要性不言而喻。它不僅僅是一個工具，更是一種思維模式，能幫助我們更有效地管理程式碼與協同合作。它的應用範圍不只局限於軟體開發，還能擴展到文件或討論資訊的管理，這也是我決定以它作為我的第一個系列文章的原因！&lt;/p&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_2/"&gt;Git 系列分享 - p.0 版本控制是什麼？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="正文"&gt;正文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_3/"&gt;Git 系列分享 - p.1 Git是什麼？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_4/"&gt;Git 系列分享 - p.2 Git 對於修改的文件是怎麼劃分的呢？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_5/"&gt;Git 系列分享 - p.3 第一次使用 Git：專案初始化 git init&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_6/"&gt;Git 系列分享 - p.4 你是誰？git config 的配置與層級&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_7/"&gt;Git 系列分享 - p.5 檔案追蹤並納入紀錄！（git status、git add）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_8/"&gt;Git 系列分享 - p.6 正式提交一個commit囉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_9/"&gt;Git 系列分享 - p.7 版本控制的篩選器 - .gitignore 的使用與規則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_10/"&gt;Git 系列分享 - p.8 Git 的核心力量 - 分支 (Branch)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_11/"&gt;Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_12/"&gt;Git 系列分享 - p.10 整合工作線：&lt;code&gt;git merge&lt;/code&gt; 的兩種策略與原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_13/"&gt;Git 系列分享 - p.11 歷史重寫與整理：&lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;squash&lt;/code&gt; 的魔法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_14/"&gt;Git 系列分享 - p.12 歷史控制：&lt;code&gt;git reset&lt;/code&gt;、&lt;code&gt;git revert&lt;/code&gt; 與 &lt;code&gt;git cherry-pick&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_15/"&gt;Git 系列分享 - p.13 遠端協作的橋樑：&lt;code&gt;git remote&lt;/code&gt;、&lt;code&gt;git pull&lt;/code&gt; 與 &lt;code&gt;git push&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_16/"&gt;Git 系列分享 - p.14 啟動協作：git fork 與 git clone 的差異&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_17/"&gt;Git 系列分享 - p.15 `git flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_18/"&gt;Git 系列分享 - p.16 效率小工具：Stash, Tag, Grep與 Reflog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://echoHaku.github.io/posts/post_git_19/"&gt;Git 系列分享 - p.17 進階工作流：Hooks、Patch 與 Cherry-Pick&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>從孩子身上學到的事：給迷惘大人的一封信〈What adults can learn from kids〉</title><link>https://echoHaku.github.io/posts/post_6/</link><pubDate>Mon, 14 Jul 2025 13:39:28 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_6/</guid><description>&lt;h2 id="why-this"&gt;Why this?&lt;/h2&gt;
&lt;p&gt;最近的我時常在想：為什麼我總是如此畏首畏尾？做任何事情都瞻前顧後，深怕一不小心就會搞砸一切。為什麼我會如此害怕失敗？為什麼我總是遲疑，明明投入了心力卻又一事無成的感覺？&lt;br&gt;
但我記得小時候的自己並不是這樣子的啊。那時候的我是一個勇往直前、對什麼事情都充滿興趣的小孩。到底在長大的過程中，我遺失了哪些重要的特質？又該怎麼把它們找回來？&lt;br&gt;
這篇文章是我一邊閱讀，一邊反思，一邊自我提問後整理出來的內容及實踐計畫。&lt;/p&gt;
&lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
&lt;h3 id="好奇心與學習的熱忱"&gt;好奇心與學習的熱忱&lt;/h3&gt;
&lt;p&gt;孩子總是對世界充滿了好奇，總是「十萬個為什麼？」問也問不完。&lt;br&gt;
反觀現在的我，很害怕面對問題，明明知道自己一定是無知的，但是面對未知，我卻是選擇逃避、忽視，&lt;br&gt;
有時候並不是因為不知道答案而受挫，而是害怕去面對「不知道」這種感受。&lt;br&gt;
我知道，好奇心是驅動成長的引擎。只有保持對世界的興趣，才能持續學習與蛻變。&lt;/p&gt;
&lt;p&gt;我該怎麼行動去拿回「好奇心」呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延續 &lt;a href="https://echoHaku.github.io/posts/post_5/"&gt;用一個月的微習慣導向新的生活《從1%的選擇開始，去做你真正渴望的事》&lt;/a&gt; 提到的內容，設定學習目標，每月設定一個新主題，探索不同領域的知識。&lt;/li&gt;
&lt;li&gt;每天記錄今天學習或觀察到的小細節，記錄自己的「小確幸」。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="創造力與想像力"&gt;創造力與想像力&lt;/h3&gt;
&lt;p&gt;對孩子來說，用枕頭蓋房子、拿湯匙當超人裝備是再自然不過的事。他們的世界沒有「不合理」，只有「我想做做看」。&lt;br&gt;
但大人呢？在長大的過程當中，被「理性」與「效率」的框架束縛，想像力被逐漸磨平，創造變成一種奢侈。
創造力是解決問題與創新的最核心能力，也是我們不可或缺的東西。&lt;/p&gt;
&lt;p&gt;我該怎麼行動拿回「創造力」呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;培養自己的創作習慣（寫日記、塗鴉）&lt;/li&gt;
&lt;li&gt;練習「腦力激盪」：列出 10 個不設限的瘋狂想法，享受不完美的創造。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="真誠與表達"&gt;真誠與表達&lt;/h3&gt;
&lt;p&gt;當孩子生氣，他們會哭；當他們開心，他們會跳，真誠得不加修飾。而我學會了壓抑。明明喜歡一件事因為怕造成他人過度的解釋我也不會說出「我喜歡」。就算討厭一個人，我也會擔心造成其他人的困擾，而不敢說出「我討厭」、「我生氣」。久而久之，我甚至無法清楚感受自己的情緒與傾向，而變得更加迷惘。&lt;/p&gt;
&lt;p&gt;我該怎麼行動拿回「真誠」呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在每日覆盤中加入「情緒日記」區塊，寫下今天的感受、觸發點與自己的回應。&lt;/li&gt;
&lt;li&gt;正視自己對事物的喜好與厭惡，不再否定情緒的存在。&lt;/li&gt;
&lt;li&gt;建立自己的喜好清單&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="活在當下"&gt;活在當下&lt;/h3&gt;
&lt;p&gt;孩子玩積木時，當下的事情就是全世界。他們不擔心訊息沒回，也不焦慮明天的計畫，只專注於現在。而我的大腦總是充斥著「昨天沒做好的事」「明天要補救的事情、明天的待辦事項」等等，昨天的遺憾、明天的焦慮多到我沒有辦法好好專心於手邊的事，不僅是專注力低下，也導致同樣的事情我必須做兩遍才能完成。&lt;/p&gt;
&lt;p&gt;我該怎麼行動拿回「當下」呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制自己划手機的情況，練習全神貫注於眼前的人事物。&lt;/li&gt;
&lt;li&gt;每周刻意給自己留出「無目的」時間，單純做一些喜歡的事情，單純享受拼圖、散步、看漫畫這些微小卻令人放鬆的活動。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="勇於嘗試與失敗"&gt;勇於嘗試與失敗&lt;/h3&gt;
&lt;p&gt;孩子們跌倒就跌倒，爬起來後還是繼續奔跑，直到可以站穩腳步的跑為止，他們不害怕出糗、不害怕痛、不害怕犯錯，會反覆嘗試直到會為止。反觀我們大人，卻經常在「萬一&amp;hellip;怎麼辦？」的念頭中停下腳步。我們怕失敗、怕被看不起、怕被嘲笑，導致很多夢想不是因為做不到，而是還沒開始就被想像中的失敗嚇退。&lt;/p&gt;
&lt;p&gt;我該怎麼行動拿回「勇於行動」呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每月挑戰一件平常不敢嘗試的小事（公開說出想法、報名陌生課程、嘗試陌生技能等）。&lt;/li&gt;
&lt;li&gt;每日的覆盤去記錄自己的錯誤和學習，視為自己的收穫、成長的證明。&lt;/li&gt;
&lt;li&gt;建立自己的「失敗清單」為自己的曾經的失敗鼓掌。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="３-actions"&gt;３ Actions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在每日覆盤中加入 4 個新區塊：情緒日記、生活小細節、錯誤學習、腦力激盪。&lt;/li&gt;
&lt;li&gt;每週安排「無目的時間」，讓自己純粹享受當下。&lt;/li&gt;
&lt;li&gt;每月挑戰一件小事，紀念自己的勇敢事蹟！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="finally"&gt;Finally&lt;/h2&gt;
&lt;p&gt;這次的反思，是從閱讀與生活中誕生的。我試著回顧童年時那個更真誠、更勇敢、更好奇的自己，也開始思考：我是不是可以用「大人的力量」，去守護「孩子的特質」？&lt;/p&gt;
&lt;p&gt;孩子也許沒有我們的經驗與理性，但他們身上，有著我們曾經擁有卻遺忘的智慧。&lt;/p&gt;
&lt;p&gt;不知道你是否也曾有過類似的感覺？如果你也想從孩子身上找回那些失落的特質，不妨靜下心來，好好和內在的自己聊一聊。&lt;/p&gt;</description></item><item><title>用一個月的微習慣導向新的生活《從1%的選擇開始，去做你真正渴望的事》</title><link>https://echoHaku.github.io/posts/post_5/</link><pubDate>Tue, 10 Jun 2025 09:00:41 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_5/</guid><description>&lt;h2 id="why-this"&gt;Why this?&lt;/h2&gt;
&lt;p&gt;一次偶然的機會，我翻到《從 1% 的選擇開始》封底，看見作者拋出的七個靈魂提問。每一道問題都像在提醒我：若不先釐清方向，就只能在迷霧中打轉。於是，我毫不猶豫將它加入購物車，期盼閱讀後能真正理解問題的意義，並找到屬於自己的答案。&lt;/p&gt;
&lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
&lt;p&gt;整本書的概念圍繞著這個主題&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;用七個問題鎖定人生方向，再透過每日早晨 7 分鐘，選定當天最有價值的 5 件事&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所謂最有價值的五件事必須同時符合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;與我的價值觀一致&lt;/li&gt;
&lt;li&gt;能推進我此刻最想實現的目標&lt;/li&gt;
&lt;li&gt;產出高於平均的收穫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能主動過濾雜音，刻意放棄「不重要卻吵雜」的任務。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「不是意向，而是你走的方向決定了你的目的地。」也就是說，你的行為 決定了你的目的地。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者建議 &lt;strong&gt;90 天一次回顧與校準&lt;/strong&gt;，確保每天的行動始終貼近終極目標。&lt;br&gt;
換算下來，只要持續完成每日 5 件高價值行動，90 天就累積 450 次有意義的前進。&lt;br&gt;
我總結了一下七個有意義的問題如下表：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;問題&lt;/th&gt;
 &lt;th&gt;定義及執行&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;你是否清醒地活著？&lt;/td&gt;
 &lt;td&gt;是否真正地知道自己想要的是什麼？&lt;br/&gt;思考自己的人生目的，與自己的價值觀；而後將專注力放到這些事情上面，就會發現一世界也在幫助你得到你所想要的。&lt;br/&gt;透過 GTD 把腦中雜訊全數寫下，抽絲剝繭出「此刻最重要的使命」。&lt;br/&gt;使命確認好後，它就像馬鞍與配劍，讓我能駕馭人生並斬斷枝節。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;你有企圖心嗎？&lt;/td&gt;
 &lt;td&gt;企圖心是一股推進自己到達理想狀態的內燃機。&lt;br/&gt;作者提醒：少說「我想要」，&lt;strong&gt;改成「我已決定要&amp;hellip;」&lt;/strong&gt;。&lt;br/&gt;設定 90 天目標時，定期確認自己達成目標的狀況，同時盤點阻礙、抗拒改變的原因與「不改變的代價」，才能真正跨出舒適圈。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;你是否持續成長與學習？&lt;/td&gt;
 &lt;td&gt;成長 = 學習後捨棄舊習 + 建立新習慣；最後成就更好的生活。&lt;br/&gt;思考是一門高難度投資，持續思考找到可以改進的地方。&lt;br/&gt;像是「現在把專注力放在這裡是最好的選擇嗎？把時間花在這件事上是否會讓生活更加豐富、更有意義？」等去找到可以改進之處。&lt;br/&gt;設定90天的學習目標。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;你是否全心投入？&lt;/td&gt;
 &lt;td&gt;上午 11 點前完成 5 件最重要的事，並確保家人/重要他人相關行動也在其中。&lt;br/&gt;為每個待辦預設收穫，確保與現在的價值觀、所追求的人生目的目標有關，堅決排除「看似忙碌卻不能創造結果」的事項。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;你是否經得起磨練？&lt;/td&gt;
 &lt;td&gt;書中以美式橄欖球比喻：若沒跨過最後一碼線，前面再努力也枉然。&lt;br/&gt;作者建議定期在行事曆安排「挑戰日」，刻意拉高強度，鍛鍊耐力與執行肌肉。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;你是否處於心流？&lt;/td&gt;
 &lt;td&gt;當我全神貫注於熱愛的工作，時間感被扭曲，而收穫的能量又回灌自身——那就是理想狀態。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;你是否有信仰？&lt;/td&gt;
 &lt;td&gt;信念是一股隱形推力，讓自己充滿信心去面對挑戰。&lt;br/&gt;故而全然的相信自己做得到、相信身邊的人可以給自己力量是一件很重要的想法。&lt;br/&gt;作者鼓勵平衡左右腦：左腦複製過往成功框架，右腦釋放創造力與當下覺知，如同小孩不畏挫敗勇往直前。&lt;br/&gt;唯有身心靈協調，才能長久前行。盡量去平衡左右腦，理性同時體驗生活。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;接受自己要去走一條不那麼舒服的路，我們才能避免「原地繞圈」的窘境，畢竟不可能我們重複著同樣的動作，卻能夠擁有不同的結果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="３-actions"&gt;３ Actions&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;本書的最後有30天計畫，並且有個90天計畫去做執行，會執行看看並去做review。&lt;/li&gt;
&lt;li&gt;每日覆盤當中，去觀察我訂定決策的原因和傾向。&lt;/li&gt;
&lt;li&gt;嘗試多用右腦去讓自己習慣「不舒服」的感覺，讓自己能更習慣於跳脫僵固的思考。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="finally"&gt;Finally&lt;/h2&gt;
&lt;p&gt;《從 1% 的選擇開始》像是把我這些年零散吸收的生產力概念，整合成一條清晰可執行的路徑。接下來我將啟動 30 + 90 天的實驗，檢驗這套方法是否真能帶來質變；成果如何，敬請期待下回分享！&lt;/p&gt;</description></item><item><title>肢體語言洩漏了一切〈Your Body Language May Shape Who You Are〉</title><link>https://echoHaku.github.io/posts/post_4/</link><pubDate>Mon, 02 Jun 2025 16:46:45 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_4/</guid><description>&lt;h2 id="why-this"&gt;Why this?&lt;/h2&gt;
&lt;p&gt;「不自信」這像是張標籤已經貼在我身上好多年了。不論是面試、報告，還是日常與人互動，常常有人告訴我：「你看起來很緊張」「你是不是很沒自信？」——但我明明什麼話都還沒說，他們是怎麼感受到的？&lt;br&gt;
我開始懷疑，是不是自己在「不知不覺中」，就已經把某種訊號傳遞出去了？&lt;br&gt;
在這場 TED Talk 裡，Amy Cuddy 給了我一個答案，也是我從未想過的答案：原來是&lt;strong&gt;肢體語言洩漏了一切&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="肢體語言"&gt;肢體語言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;「透過改變我們的肢體語言，就能影響我們的心理狀態與行為表現。這不只是讓你『看起來』有自信，而是讓你真正成為一個更有自信的自己。」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="肢體語言是什麼"&gt;肢體語言是什麼？&lt;/h3&gt;
&lt;p&gt;她用了一個關鍵詞：nonverbals，也就是非語言訊號，或者說肢體語言——姿勢、眼神、手勢、動作等，既是語言，那就表示是一種溝通的方式，是一種與人互動的方式、與自己互動的方式。&lt;br&gt;
這些訊號不僅影響他人如何看我們，更會深深影響我們「自己怎麼看自己」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;站的挺直、張開雙手都會讓你感到更有力量。&lt;/li&gt;
&lt;li&gt;抱緊雙臂、駝背等就會讓自己更加焦慮、退縮。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="power-pose"&gt;Power Pose&lt;/h3&gt;
&lt;p&gt;刻意地做出 Power pose 「高權力姿勢」就能改變人的心理與生理狀態。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;睪固酮（自信激素）上升。&lt;/li&gt;
&lt;li&gt;使我們的皮質醇（壓力激素）下降。
雖然這個荷爾蒙的變化效果在研究中仍有爭議，但一致的效果是──&lt;strong&gt;你會感覺自己變得強大、更有行動力。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同時她也提到　「Don&amp;rsquo;t fake it till you make it. Fake it till you become it.」&lt;br&gt;
不是等到自己準備好了才展現自信，而是先透過姿勢與行動「假裝」有自信，讓大腦開始相信你真的有，最終你就會成為那個有自信的人。就像是腦袋影響著身體，同時身體也影響著腦袋。&lt;/p&gt;
&lt;h2 id="３-actions"&gt;３ Actions&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在面對挑戰時，到廁所裡，練習 Power pose，包括站的挺拔、雙手打開、挺胸、深呼吸，幫自己喚醒內在的力量。&lt;/li&gt;
&lt;li&gt;日常覺察自己肢體&lt;br&gt;
當感覺緊張或沒自信時，試著問問自己：&lt;br&gt;
「我現在的姿勢是在縮小我自己嗎？」&lt;br&gt;
提醒自己：肩膀放鬆、抬頭挺胸、呼吸深長，這些小動作都能逐步改變你傳遞出去的訊息。\&lt;/li&gt;
&lt;li&gt;養成「行為引導內在」的習慣&lt;br&gt;
不只姿勢，說話語氣、眼神的接觸、走路的節奏，這些外在行為都能反過來塑造我們的心態。&lt;br&gt;
每天練習一點點，讓「行動」帶著我們成長。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="finally"&gt;Finally&lt;/h2&gt;
&lt;p&gt;Amy Cuddy 的話語提醒了我一件重要的事——&lt;strong&gt;你可以用行為，重新定義你是誰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不需要等到「萬事俱備」才開始展現自信，你現在就可以用一個姿勢、一個動作，邁出那一步。&lt;br&gt;
無論是外在的強勢壓力，或內在的自我懷疑，我們都有選擇：用行動塑造那個更有力量的自己。&lt;/p&gt;
&lt;p&gt;我想成為一個&lt;strong&gt;低調但堅定、有自信但不張狂的人&lt;/strong&gt;，能冷靜地處理挑戰，也能自在地展現自我。這是一種態度，也是一種可以練習的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Don&amp;rsquo;t fake it till you make it. Fake it till you become it.&amp;rdquo; ——Amy Cuddy&lt;/p&gt;</description></item><item><title>恆毅力〈Grit: The power of passion and perseverance〉</title><link>https://echoHaku.github.io/posts/post_3/</link><pubDate>Mon, 26 May 2025 16:43:27 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_3/</guid><description>&lt;h2 id="why-this"&gt;Why this?&lt;/h2&gt;
&lt;p&gt;在設定了長期目標後，接踵而來的問題就是 &lt;strong&gt;「如何讓自己在面對長期目標時更加堅定呢？」&lt;/strong&gt;&lt;br&gt;
過往的自己總是因為進展緩慢或挫折而輕易放棄，在努力了大半之後因為看不到成果而選擇放棄，有時甚至自己是否有能力達成想要的人生樣貌。在這樣的狀態下，我開始尋找一些能夠帶來啟發的內容，於是看到了 Angela Lee Duckworth 的 TED Talk〈Grit: The power of passion and perseverance〉。這場演講讓我重新看待成功與努力之間的關係，也讓我重新審視我對於生活投入的方式和心態，而與這些主題息息相關的就是Grit，恆毅力。&lt;/p&gt;
&lt;h2 id="grit"&gt;Grit&lt;/h2&gt;
&lt;h3 id="grit-是什麼"&gt;Grit 是什麼？&lt;/h3&gt;
&lt;p&gt;Grit 是一種面對長期目標所展現出來的熱情與堅持不懈的毅力，不是三分鐘熱度，而是像長跑選手一樣的耐力與毅力──日復一日的努力、持續地投入、堅持實踐，直到想像中的未來成為了現實。&lt;/p&gt;
&lt;p&gt;她強調，成功並非只是靠智商（IQ）或是天賦，因為人生並不只是一場知識競賽。許多具有高智力的人，因為缺乏持續努力與穩定投入，最終無法實現他們的潛力，成為平庸的人。反之，擁有Grit的人，即便起始點平凡，卻能夠&lt;strong&gt;靠著堅持而走得更遠&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這場演講讓我重新定義了幫我重新定義了「成功」與「努力」：&lt;br&gt;
🎯&lt;strong&gt;成功（Success）&lt;/strong&gt;&lt;br&gt;
成功 = 長期投入目標 + 不輕言放棄的態度（Grit）。成功不屬於聰明的人，而屬於堅持到底的人。&lt;/p&gt;
&lt;p&gt;💪 &lt;strong&gt;努力（Effort）&lt;/strong&gt;&lt;br&gt;
努力不只是「拼命一下」或「彌補不足」，而是持續性、耐力型的投入，願意長時間為同一個目標努力不懈。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Grit is passion and perseverance for very long-term goals. Grit is having stamina. Grit is sticking with your future, day in, day out.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這句話讓我明白：「成功」不是一時衝刺的結果，而是我們選擇堅持走一條不確定但重要的道路。&lt;/p&gt;
&lt;h3 id="如何培養grit"&gt;如何培養Grit？&lt;/h3&gt;
&lt;p&gt;Duckworth提出了一個核心方法：成長型思維（Growth Mindset）。這種思維相信能力是可以透過學習與努力慢慢提升。我們必須允許自己犯錯、接受失敗、願意失敗、願意挑戰、願意重新開始並從錯誤中學習。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“We have to be willing to fail, to be wrong, to start over again with lessons learned.”&lt;/p&gt;</description></item><item><title>如何為未來的自己做準備：〈You Don’t Actually Know What Your Future Self Wants〉</title><link>https://echoHaku.github.io/posts/post_2/</link><pubDate>Thu, 22 May 2025 08:57:55 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_2/</guid><description>&lt;h2 id="why-this"&gt;Why this?&lt;/h2&gt;
&lt;p&gt;最近總在思考 &lt;strong&gt;「該如何為未來的自己鋪路？」&lt;/strong&gt;&lt;br&gt;
列出了許多可以學習的方向、可以嘗試的事情，目的僅是為了讓未來換工作、轉職能更順利。&lt;br&gt;
但在擬定這些「對未來有幫助的選擇」時，心裡又冒出了一個聲音：&lt;strong&gt;這真的是我要的嗎？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;過去也有好多次，後悔自己沒有選擇一個更好的路、後悔自己把時間花在某些的事情上，甚至下定決心要做但事情做完後又覺得好像什麼也沒得到。
回頭看自己做過的選擇，總疑惑當時為什麼會那樣決定，為什麼要花時間在那些現在看來「一點用都沒有」的事情上。
未來的我，會不會也這樣看現在的自己？會不會也後悔我現在做的決定？這樣的想法困擾了我好一陣子，也讓我在行動上遲疑不前。
所以我聽了Shankar Vedantam 的 TED Talk —— “You Don&amp;rsquo;t Actually Know What Your Future Self Wants”。
這場演講，並沒有給我一個確定的答案，卻讓我對「預測未來的自己」這件事，有了全新的理解。&lt;/p&gt;
&lt;h2 id="未來是無法預測的"&gt;未來是無法預測的&lt;/h2&gt;
&lt;h3 id="未來是無法預測的而我也在不斷的變化中"&gt;未來是無法預測的，而「我」也在不斷的變化中&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;The future is unknow, and it is unknowable.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vedantam 說，我們無法預測未來，這不是因為我們不夠努力，而是因為未來本身就不可預知。
十年前，我們無法想像智慧型手機會如何改變生活；更別說當時根本沒聽過 podcast，今天卻已經是日常的一部分。
&lt;strong&gt;但比外在世界更難預測的，是我們自己。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即使都是我，每個時間的自己互相都是陌生人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;講者在演講中提到「忒修斯之船（Ship of Theseus）」：勇士忒修斯的船因為時間而腐壞，一塊塊木板被替換，直到整艘船的零件全都換成新的——那它還是原來的那艘船嗎？
我們也是如此。生物學上，我們的細胞會不斷汰換；十年前的我和今天的我，可能已經沒有一個細胞是相同的，我們已經是不同的人了。而心理層面呢？我們的價值觀、觀點、目標，也都在不斷變化。&lt;/p&gt;
&lt;p&gt;不只是環境會改變，我們自身也會變得截然不同。我們擁有不同的視角、不同的角色，甚至不同的世界觀。而我們卻總是忽略這一點，彷彿未來的自己會一直和現在的自己保持一致。就像我現在回頭翻看國中時期的日記，常會驚訝於當時的想法和價值觀和現在有多麼不同——甚至會覺得當時的自己幼稚又不合理，難以理解當初為什麼會那樣思考與選擇。
&lt;strong&gt;我們總以為自己已經成熟、已經知道自己是誰，卻忘了：未來的自己，也很可能會用相同的眼光看待現在的我，覺得這個我很奇怪、很陌生。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;現在很想要的東西，未來的我們可能會帶著困惑與懊悔回頭看，問：「你們怎麼會覺得我會想要這個？」這樣的不確定感，讓人害怕，但也提醒我一件事：&lt;strong&gt;現在所做的選擇，頂多只是「對此刻的自己來說最好的選擇」，不一定對未來有意義；但我們卻總以為是在為「更好的未來」做出安排。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="三個建議去讓未來的自己如今的自己"&gt;三個建議去讓未來的自己如今的自己&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;保持好奇心&lt;br&gt;
&lt;strong&gt;接受未來的自己會不一樣&lt;/strong&gt;，因此，不要用現在的眼光限制自己。與其只專注在眼前的興趣和技能，不如留點空間給新鮮事物。去接觸、去嘗試，哪怕只是短暫地認識一個新的領域，也許未來的我會因此多一個選項、一個方向。利用好奇心去成為未來自我的建築師。&lt;/li&gt;
&lt;li&gt;保持謙遜&lt;br&gt;
今天我所相信的，也許明天自己就推翻了。社會制度、價值觀都不斷地在變化，我的信念也一樣。別人不同的觀點也值得傾聽，因為最大的分歧，往往來自未來的自己。謙遜地表達自己的立場，也給自己留有修正與成長的空間。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;勇敢去做&lt;/strong&gt;&lt;br&gt;
當我說「我沒有能力做到」的時候，其實多半是「我現在還沒學會怎麼做」。這不是否定，而是一種可能。只要開始，即使走得慢，即使現在不熟悉，未來的我終將比今天更靠近我想成為的樣子，而他也會很開心今天的自己所做的努力。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;與其追求一個萬無一失的「未來計畫」，不如培養一種能力：當未來到來、當我改變時，我能調整、能理解，也能原諒並感謝過去的自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="３-actions"&gt;３ Actions&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;寫信給未來的自己&lt;br&gt;
我原本就有用 Gmail 的排程功能寄信給半年後的自己，檢視年度目標的達成與否。未來，我想嘗試寫給五年後的自己，聊聊現在的夢想、價值觀與恐懼，也許五年後的我會驚訝於這些想法的變與不變，更清楚的看見自己的不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;年度設定加入「嘗試一個全新的領域」&lt;br&gt;
不一定要學得精通，也不需要為了什麼目的。只是單純去接觸陌生的領域，例如閱讀一本不熟悉主題的書、參加一個沒接觸過的活動，或學一項從沒學過的技能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每月反思問題加入「我還同意我過去的選擇嗎？」&lt;br&gt;
建立一個簡單的反思習慣，檢視上個月的選擇與行動，並誠實問自己：這些決定還符合我現在的價值觀嗎？這樣的提問，讓我與自己保持對話，也讓改變更有意識地發生。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="finally"&gt;Finally&lt;/h2&gt;
&lt;p&gt;我們無法預測未來，也無法保證現在的選擇一定是對的。但這不代表我們什麼都不能做。我們能做的，是以彈性與謙遜的心態前進，保留空間給那個還沒出現的「我」。
想起來之前看到的一個論點&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;未來的我 = 現在的我 + 過去的我&lt;/p&gt;</description></item><item><title>使用 Hugo GitHub 建立個人部落格</title><link>https://echoHaku.github.io/posts/post_1/</link><pubDate>Fri, 16 May 2025 15:36:43 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_1/</guid><description>&lt;h2 id="起源與目的"&gt;起源與目的&lt;/h2&gt;
&lt;p&gt;在 2025 年 5 月的這段時間，我正經歷一段迷茫期。思考了許久，試著找出一種方式，能讓自己對所理解與學習的知識更加有自信，也希望能夠逐步建立起屬於自己的知識體系。最終，我決定開始寫部落格，分享自己學習到的內容、遇到的問題、解決的過程，以及個人的思考與心得。&lt;/p&gt;
&lt;p&gt;雖然不知道這樣的分享能夠持續多久，但我希望能盡可能長久地維持這個習慣，把自己腦中吸收的知識透過文字整理出來。經過一番資料查找後，我決定透過 Hugo 搭配 GitHub 來實踐這個想法。&lt;/p&gt;
&lt;p&gt;選擇這個方法，是因為它不需要太多繁瑣的 coding，也不必花太多時間糾結於主題與配色的選擇，對我來說是個簡單又實用的開始。&lt;/p&gt;
&lt;p&gt;以下是我所使用的建置方式與流程。&lt;/p&gt;
&lt;h2 id="實作"&gt;實作&lt;/h2&gt;
&lt;h3 id="stage-1-工具準備工具準備"&gt;Stage 1. 工具準備工具準備&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;安裝 Git (可選擇搭配 視覺化GUI工具)&lt;/li&gt;
&lt;li&gt;安裝 Hugo&lt;/li&gt;
&lt;li&gt;註冊 GitHub 帳號&lt;/li&gt;
&lt;li&gt;選定一個 Hugo theme&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="stage-2-建立並設定hugo專案"&gt;Stage 2. 建立並設定Hugo專案&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先在GitHub上創建兩個repository，並將其clone到地端&lt;br/&gt;
一個取名為&lt;code&gt;blogger&lt;/code&gt;，用來儲存網站原始碼與內容（文章、圖片等） &lt;br/&gt;
一個則是取名為 &lt;code&gt;username.github.io&lt;/code&gt;，用以儲存hugo為我們產生的靜態內容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化Hugo專案&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt; cd blogger
 hugo new site sitename
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此命令會在 &lt;code&gt;blogger/sitename&lt;/code&gt; 下建立 Hugo 專案。會看到 /blogger/sitename/ 底下許多的子folder&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝主題 (theme)
在 hugo themes 上選定好一個主題，可以看到 &amp;ldquo;download&amp;rdquo; 主題的按鈕，通常可以連結到該theme的github page&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt; cd sitename
 git submodule add 該theme的git themes/rusty-typewriter
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個指令的目的是把該主題鑲嵌的概念到你的repository上，當這個主題的作者有所變動，我們這邊也可以有最新的commit結果，可以確認 .gitmodules 的檔案是否有正確的新增。
修改 &lt;code&gt;sitename/hugo.toml&lt;/code&gt;&lt;/p&gt;</description></item></channel></rss>