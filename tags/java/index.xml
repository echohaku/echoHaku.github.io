<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on ECHOHAKU BLOG</title><link>https://echoHaku.github.io/tags/java/</link><description>Recent content in Java on ECHOHAKU BLOG</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 19 Jan 2026 10:06:48 +0800</lastBuildDate><atom:link href="https://echoHaku.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Serialize 到底是什麼？</title><link>https://echoHaku.github.io/posts/post_tech_1/</link><pubDate>Mon, 19 Jan 2026 10:06:48 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_tech_1/</guid><description>&lt;h2 id="名詞定義"&gt;名詞定義&lt;/h2&gt;
&lt;h3 id="序列化-serialization"&gt;序列化 &lt;code&gt;serialization&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;序列化是指 將記憶體中的物件（Object）依特定序列化機制，轉換成可儲存或可傳輸的線性格式（例如 bytes 或文字格式）過程。&lt;br&gt;
在物件被序列化之後，資料可以被存放在檔案中，或透過網路傳遞給另一個系統，並在必要時再被還原。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：序列化是一個廣義概念，實作方式包含 Java 原生序列化、JSON、XML、Protobuf 等，不同機制的行為與限制並不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="反序列化-deserializing"&gt;反序列化 &lt;code&gt;deserializing&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;反序列化是指&lt;strong&gt;將已序列化的資料，依原本的序列化機制，還原為記憶體中的物件狀態&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id="java-反序列化的執行順序"&gt;Java 反序列化的執行順序：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;依 package name 與 class name 尋找 class&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若找不到，會直接拋出 &lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比對 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;比對序列化資料中記錄的 UID 與目前 class 定義中的 UID&lt;/li&gt;
&lt;li&gt;若不一致，會拋出 &lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="serialversionuid"&gt;serialVersionUID&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;serialVersionUID&lt;/code&gt; 是 Java 原生序列化中，用來識別 class 版本的 ID，其目的在於&lt;strong&gt;控制反序列化時的版本相容性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="為什麼需要-serialversionuid"&gt;為什麼需要 serialVersionUID？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若 class &lt;strong&gt;未明確宣告 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;JVM 會根據 class 結構（欄位、方法、繼承關係等）自動產生&lt;/li&gt;
&lt;li&gt;只要 class 結構稍有變動，UID 就可能改變&lt;/li&gt;
&lt;li&gt;導致舊資料在反序列化時失敗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="範例說明"&gt;範例說明&lt;/h3&gt;
&lt;p&gt;假設：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;User&lt;/code&gt; class 原本包含欄位 &lt;code&gt;(name, age, phone)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;將其序列化並儲存在檔案 A 中&lt;/li&gt;
&lt;li&gt;後續版本中刪除了 &lt;code&gt;phone&lt;/code&gt; 欄位，並修改了 &lt;code&gt;toString()&lt;/code&gt; 方法
若 &lt;strong&gt;未明確指定 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;JVM 可能重新計算 UID&lt;/li&gt;
&lt;li&gt;嘗試反序列化檔案 A 時，會拋出 &lt;code&gt;InvalidClassException&lt;/code&gt;
若 &lt;strong&gt;有明確指定 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;JVM 會認定這仍是同一個 class&lt;/li&gt;
&lt;li&gt;即使欄位有所差異，仍允許反序列化（新欄位可能為預設值）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="serialversionuid-通常如何設定"&gt;serialVersionUID 通常如何設定？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直接指定固定值&lt;/strong&gt;
&lt;code&gt;private static final long serialVersionUID = 1L;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由工具或 JVM 根據 class 結構產生出一個 64-bit hash value（通常唯一）
&lt;ul&gt;
&lt;li&gt;package name&lt;/li&gt;
&lt;li&gt;class name&lt;/li&gt;
&lt;li&gt;繼承關係&lt;/li&gt;
&lt;li&gt;非 private 的方法與欄位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="所有-class-都設定為-1l的時候jvm會允許反序列化但可能會造成"&gt;所有 class 都設定為 1L的時候，JVM會允許反序列化，但可能會造成&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新欄位可能會直接是預設值&lt;/li&gt;
&lt;li&gt;舊資料結構可能與新邏輯不相容&lt;/li&gt;
&lt;li&gt;問題不一定會在反序列化當下立即暴露&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="什麼時候會建議都設定為-1l-"&gt;什麼時候會建議都設定為 1L ？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DTO&lt;/li&gt;
&lt;li&gt;Cache Object&lt;/li&gt;
&lt;li&gt;Session Object&lt;/li&gt;
&lt;li&gt;欄位變動後仍可以向後相容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="什麼時候應該要調整serialversionuid"&gt;什麼時候應該要調整SerialVersionUID？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;欄位意義改變&lt;/li&gt;
&lt;li&gt;移除欄位&lt;/li&gt;
&lt;li&gt;改變繼承結構&lt;/li&gt;
&lt;li&gt;改變 &lt;code&gt;transient&lt;/code&gt; / &lt;code&gt;non-transient&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;public class ExampleClass implements Serializable { 
	private static final long serialVersionUID = 1L;
	// class details... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="在java當中什麼時候該-implements-serializable"&gt;在JAVA當中什麼時候該 implements Serializable？&lt;/h2&gt;
&lt;p&gt;判斷標準：「物件會被轉換成 byte stream 並在 JVM 之外存活或傳遞」時，才需要 &lt;code&gt;implements Serializable&lt;/code&gt;&lt;/p&gt;</description></item></channel></rss>