<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on ECHOHAKU BLOG</title><link>https://echoHaku.github.io/tags/java/</link><description>Recent content in Java on ECHOHAKU BLOG</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 20 Jan 2026 15:20:21 +0800</lastBuildDate><atom:link href="https://echoHaku.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>@GeneratedValue的意義和作用</title><link>https://echoHaku.github.io/posts/post_tech_3/</link><pubDate>Tue, 20 Jan 2026 15:20:21 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_tech_3/</guid><description>&lt;h2 id="generatedvalue-定義"&gt;@GeneratedValue 定義&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JAVA 持久化 API (JPA) 中的一個annotation。&lt;/li&gt;
&lt;li&gt;指定 entity 的主鍵( primary key ) 的生成策略&lt;/li&gt;
&lt;li&gt;通常會搭配 @Id 使用&lt;/li&gt;
&lt;li&gt;strategy
&lt;ul&gt;
&lt;li&gt;GenerationType.IDENTITY：依賴DB的 AUTO_INCREMENT 特性，通常用於MySQL、MariaDB (Oracle不支持)&lt;/li&gt;
&lt;li&gt;GenerationType.SEQUECE：用DB序列對象生成主鍵，通常用於Oracle、&lt;a href="https://echoHaku.github.io/posts/post_tech_2/"&gt;PostgreSQL&lt;/a&gt; (MySQL不支持)
&lt;ul&gt;
&lt;li&gt;需要設定 db sequence&lt;/li&gt;
&lt;li&gt;支援batch insert&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GenerationType.TABLE：專門有一張表來模擬序列&lt;/li&gt;
&lt;li&gt;GenerationType.UUID：讓JPA自行生成一個UUID作為值&lt;/li&gt;
&lt;li&gt;GenerationType.AUTO：JPA自行決定要如何產生唯一值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>使用postgreSQL時數字類型的 ID 該如何使用 sequence 功能</title><link>https://echoHaku.github.io/posts/post_tech_2/</link><pubDate>Tue, 20 Jan 2026 15:18:32 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_tech_2/</guid><description>&lt;h2 id="sequence"&gt;Sequence&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PostgreSQL 是「&lt;strong&gt;原生支援 Sequence&lt;/strong&gt;」的資料庫，JPA / Hibernate 與它的整合是非常完善&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;persist/save&lt;/code&gt; 當下，你就一定能拿到 ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;create table&lt;/code&gt;時，若ID是數字自動增加的話，&lt;br&gt;
直接&lt;code&gt;CREATE SEQUENCE xxx_id_seq START WITH 1 INCREMENT BY 1;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TABLE 當中 id 設定&lt;code&gt; id INTEGER NOT NULL DEFAULT nextval('order_id_seq'),&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JAVA Entity 設定 &lt;a href="https://echoHaku.github.io/posts/post_tech_3/"&gt;@GeneratedValue&lt;/a&gt; 時搭配使用&lt;br&gt;
&lt;code&gt;@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &amp;quot;order_seq&amp;quot;)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;@SequenceGenerator(name = &amp;quot;order_seq&amp;quot;,sequenceName = &amp;quot;order_id_seq&amp;quot;,allocationSize = 1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;項目&lt;/th&gt;
 &lt;th&gt;說明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;ID 產生時機&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;INSERT 前就能取得 ID&lt;/strong&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Hibernate 行為&lt;/td&gt;
 &lt;td&gt;先 &lt;code&gt;nextval(sequence)&lt;/code&gt;，再 INSERT&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;是否支援 batch insert&lt;/td&gt;
 &lt;td&gt;支援&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;交易回滾&lt;/td&gt;
 &lt;td&gt;Sequence &lt;strong&gt;不會回滾&lt;/strong&gt;（正常行為）&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;效能&lt;/td&gt;
 &lt;td&gt;⭐⭐⭐⭐⭐（最佳）&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;搭配 &lt;a href="https://echoHaku.github.io/posts/post_tech_3/"&gt;@GeneratedValue&lt;/a&gt; 該如何使用&lt;/p&gt;</description></item><item><title>Serialize 到底是什麼？</title><link>https://echoHaku.github.io/posts/post_tech_1/</link><pubDate>Mon, 19 Jan 2026 10:06:48 +0800</pubDate><guid>https://echoHaku.github.io/posts/post_tech_1/</guid><description>&lt;h2 id="名詞定義"&gt;名詞定義&lt;/h2&gt;
&lt;h3 id="序列化-serialization"&gt;序列化 &lt;code&gt;serialization&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;序列化是指 將記憶體中的物件（Object）依特定序列化機制，轉換成可儲存或可傳輸的線性格式（例如 bytes 或文字格式）過程。&lt;br&gt;
在物件被序列化之後，資料可以被存放在檔案中，或透過網路傳遞給另一個系統，並在必要時再被還原。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：序列化是一個廣義概念，實作方式包含 Java 原生序列化、JSON、XML、Protobuf 等，不同機制的行為與限制並不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="反序列化-deserializing"&gt;反序列化 &lt;code&gt;deserializing&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;反序列化是指&lt;strong&gt;將已序列化的資料，依原本的序列化機制，還原為記憶體中的物件狀態&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id="java-反序列化的執行順序"&gt;Java 反序列化的執行順序：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;依 package name 與 class name 尋找 class&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若找不到，會直接拋出 &lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比對 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;比對序列化資料中記錄的 UID 與目前 class 定義中的 UID&lt;/li&gt;
&lt;li&gt;若不一致，會拋出 &lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="serialversionuid"&gt;serialVersionUID&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;serialVersionUID&lt;/code&gt; 是 Java 原生序列化中，用來識別 class 版本的 ID，其目的在於&lt;strong&gt;控制反序列化時的版本相容性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="為什麼需要-serialversionuid"&gt;為什麼需要 serialVersionUID？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若 class &lt;strong&gt;未明確宣告 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;JVM 會根據 class 結構（欄位、方法、繼承關係等）自動產生&lt;/li&gt;
&lt;li&gt;只要 class 結構稍有變動，UID 就可能改變&lt;/li&gt;
&lt;li&gt;導致舊資料在反序列化時失敗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="範例說明"&gt;範例說明&lt;/h3&gt;
&lt;p&gt;假設：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;User&lt;/code&gt; class 原本包含欄位 &lt;code&gt;(name, age, phone)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;將其序列化並儲存在檔案 A 中&lt;/li&gt;
&lt;li&gt;後續版本中刪除了 &lt;code&gt;phone&lt;/code&gt; 欄位，並修改了 &lt;code&gt;toString()&lt;/code&gt; 方法
若 &lt;strong&gt;未明確指定 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;JVM 可能重新計算 UID&lt;/li&gt;
&lt;li&gt;嘗試反序列化檔案 A 時，會拋出 &lt;code&gt;InvalidClassException&lt;/code&gt;
若 &lt;strong&gt;有明確指定 &lt;code&gt;serialVersionUID&lt;/code&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;JVM 會認定這仍是同一個 class&lt;/li&gt;
&lt;li&gt;即使欄位有所差異，仍允許反序列化（新欄位可能為預設值）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="serialversionuid-通常如何設定"&gt;serialVersionUID 通常如何設定？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直接指定固定值&lt;/strong&gt;
&lt;code&gt;private static final long serialVersionUID = 1L;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由工具或 JVM 根據 class 結構產生出一個 64-bit hash value（通常唯一）
&lt;ul&gt;
&lt;li&gt;package name&lt;/li&gt;
&lt;li&gt;class name&lt;/li&gt;
&lt;li&gt;繼承關係&lt;/li&gt;
&lt;li&gt;非 private 的方法與欄位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="所有-class-都設定為-1l的時候jvm會允許反序列化但可能會造成"&gt;所有 class 都設定為 1L的時候，JVM會允許反序列化，但可能會造成&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新欄位可能會直接是預設值&lt;/li&gt;
&lt;li&gt;舊資料結構可能與新邏輯不相容&lt;/li&gt;
&lt;li&gt;問題不一定會在反序列化當下立即暴露&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="什麼時候會建議都設定為-1l-"&gt;什麼時候會建議都設定為 1L ？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DTO&lt;/li&gt;
&lt;li&gt;Cache Object&lt;/li&gt;
&lt;li&gt;Session Object&lt;/li&gt;
&lt;li&gt;欄位變動後仍可以向後相容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="什麼時候應該要調整serialversionuid"&gt;什麼時候應該要調整SerialVersionUID？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;欄位意義改變&lt;/li&gt;
&lt;li&gt;移除欄位&lt;/li&gt;
&lt;li&gt;改變繼承結構&lt;/li&gt;
&lt;li&gt;改變 &lt;code&gt;transient&lt;/code&gt; / &lt;code&gt;non-transient&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;public class ExampleClass implements Serializable { 
	private static final long serialVersionUID = 1L;
	// class details... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="在java當中什麼時候該-implements-serializable"&gt;在JAVA當中什麼時候該 implements Serializable？&lt;/h2&gt;
&lt;p&gt;判斷標準：「物件會被轉換成 byte stream 並在 JVM 之外存活或傳遞」時，才需要 &lt;code&gt;implements Serializable&lt;/code&gt;&lt;/p&gt;</description></item></channel></rss>