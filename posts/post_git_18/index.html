<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Git 系列分享 - p.16 效率小工具：Stash, Tag, Grep與 Reflog | ECHOHAKU BLOG</title><link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://echoHaku.github.io/posts/post_git_18/"><meta property="og:site_name" content="ECHOHAKU BLOG"><meta property="og:title" content="Git 系列分享 - p.16 效率小工具：Stash, Tag, Grep與 Reflog"><meta property="og:description" content='在前面的篇章中，我們已經掌握了分支、合併、重寫歷史和遠端協作。本篇將介紹四個能顯著提升個人開發效率和專案穩定性的工具：stash 應對緊急插單、tag 標記正式版本、grep 快速定位內容，以及 reflog 拯救失誤。
一、git stash：臨時置物櫃（應對緊急插單） git stash 是 Git 用來應對「緊急情況」或「中斷工作」的最佳工具。它允許你在不 Commit 的情況下，暫存當前所有已追蹤（Tracked）的變更（包括暫存區和工作目錄），讓你的工作目錄回到乾淨的狀態。
1. 定義 定義： 將工作目錄和暫存區中未提交的變更，儲存到一個私有的「堆棧（Stack）」中。 注意： 預設情況下，git stash 並不會處理那些從未被 git add 過的新增檔案 (Untracked Files)，也就是新增的檔案並不會因為git stash 而被清掉。 2. 發生情境與指令 情境 A (緊急切換)： 你正在開發功能 A，但老闆要求你立即修復一個緊急 Bug。你需要切換分支，但不想 Commit 進行中的 A 程式碼。 情境 B (Pull 衝突)： 你的本地檔案有修改，但需要 git pull 遠端更新。Git 會拒絕 pull，因為怕覆蓋你的本地變更。 指令： # 將所有變更（未暫存+已暫存）儲存起來，工作目錄變乾淨 git stash push -m "功能A未完成的進度" # 列出所有已儲存的暫存 git stash list # 應用（恢復）最新的暫存，但保留暫存紀錄 git stash apply # 應用並刪除最新的暫存（最常用） git stash pop # 儲存特定檔案：Stash 通常儲存所有內容，要儲存特定檔案需要配合 git stash push -- <file> 二、git tag：頒發正式證書（標記穩定版本） git tag 用於為歷史中的某個特定 Commit 打上一個「永久的、有意義的名稱標籤」。在 Git Flow 中，它通常在 main 分支上發佈新版本時使用。'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-26T08:49:15+08:00"><meta property="article:modified_time" content="2025-11-26T08:49:15+08:00"><meta property="article:tag" content="Git"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git 系列分享 - p.16 效率小工具：Stash, Tag, Grep與 Reflog"><meta name=twitter:description content='在前面的篇章中，我們已經掌握了分支、合併、重寫歷史和遠端協作。本篇將介紹四個能顯著提升個人開發效率和專案穩定性的工具：stash 應對緊急插單、tag 標記正式版本、grep 快速定位內容，以及 reflog 拯救失誤。
一、git stash：臨時置物櫃（應對緊急插單） git stash 是 Git 用來應對「緊急情況」或「中斷工作」的最佳工具。它允許你在不 Commit 的情況下，暫存當前所有已追蹤（Tracked）的變更（包括暫存區和工作目錄），讓你的工作目錄回到乾淨的狀態。
1. 定義 定義： 將工作目錄和暫存區中未提交的變更，儲存到一個私有的「堆棧（Stack）」中。 注意： 預設情況下，git stash 並不會處理那些從未被 git add 過的新增檔案 (Untracked Files)，也就是新增的檔案並不會因為git stash 而被清掉。 2. 發生情境與指令 情境 A (緊急切換)： 你正在開發功能 A，但老闆要求你立即修復一個緊急 Bug。你需要切換分支，但不想 Commit 進行中的 A 程式碼。 情境 B (Pull 衝突)： 你的本地檔案有修改，但需要 git pull 遠端更新。Git 會拒絕 pull，因為怕覆蓋你的本地變更。 指令： # 將所有變更（未暫存+已暫存）儲存起來，工作目錄變乾淨 git stash push -m "功能A未完成的進度" # 列出所有已儲存的暫存 git stash list # 應用（恢復）最新的暫存，但保留暫存紀錄 git stash apply # 應用並刪除最新的暫存（最常用） git stash pop # 儲存特定檔案：Stash 通常儲存所有內容，要儲存特定檔案需要配合 git stash push -- <file> 二、git tag：頒發正式證書（標記穩定版本） git tag 用於為歷史中的某個特定 Commit 打上一個「永久的、有意義的名稱標籤」。在 Git Flow 中，它通常在 main 分支上發佈新版本時使用。'><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.3ecaab62029c68421263b320760b1d99eb62d6f48764aab41f3d427c5686d178.css integrity="sha256-PsqrYgKcaEISY7Mgdgsdmeti1vSHZKq0Hz1CfFaG0Xg=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://echoHaku.github.io/ style=color:inherit>ECHOHAKU BLOG</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://echoHaku.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://echoHaku.github.io/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Git 系列分享 - p.16 效率小工具：Stash, Tag, Grep與 Reflog</h1><time class=dim datetime=2025-11-26T08:49:15+08:00>November 26, 2025</time><div class=term-container><div class=tag><a href=https://echoHaku.github.io/tags/git/>#Git</a></div></ol></div><section class=page-section><p>在前面的篇章中，我們已經掌握了分支、合併、重寫歷史和遠端協作。本篇將介紹四個能顯著提升個人開發效率和專案穩定性的工具：<strong><code>stash</code> 應對緊急插單、<code>tag</code> 標記正式版本、<code>grep</code> 快速定位內容，以及 <code>reflog</code> 拯救失誤。</strong></p><h3 id=一git-stash臨時置物櫃應對緊急插單>一、<code>git stash</code>：臨時置物櫃（應對緊急插單）</h3><p><code>git stash</code> 是 Git 用來應對「緊急情況」或「中斷工作」的最佳工具。它允許你在不 Commit 的情況下，暫存當前所有<strong>已追蹤</strong>（Tracked）的變更（包括暫存區和工作目錄），讓你的工作目錄回到乾淨的狀態。</p><h4 id=1-定義>1. 定義</h4><ul><li><strong>定義：</strong> 將工作目錄和暫存區中未提交的變更，儲存到一個私有的「堆棧（Stack）」中。</li><li><strong>注意：</strong> 預設情況下，<code>git stash</code> 並不會處理<strong>那些從未被 <code>git add</code> 過的</strong>新增檔案 (Untracked Files)，也就是新增的檔案並不會因為git stash 而被清掉。</li></ul><h4 id=2-發生情境與指令>2. 發生情境與指令</h4><ul><li><strong>情境 A (緊急切換)：</strong> 你正在開發功能 A，但老闆要求你立即修復一個緊急 Bug。你需要切換分支，但不想 Commit 進行中的 A 程式碼。</li><li><strong>情境 B (Pull 衝突)：</strong> 你的本地檔案有修改，但需要 <code>git pull</code> 遠端更新。Git 會拒絕 <code>pull</code>，因為怕覆蓋你的本地變更。</li><li><strong>指令：</strong><pre tabindex=0><code># 將所有變更（未暫存+已暫存）儲存起來，工作目錄變乾淨
git stash push -m &#34;功能A未完成的進度&#34;

# 列出所有已儲存的暫存
git stash list 

# 應用（恢復）最新的暫存，但保留暫存紀錄
git stash apply 

# 應用並刪除最新的暫存（最常用）
git stash pop

# 儲存特定檔案：Stash 通常儲存所有內容，要儲存特定檔案需要配合 git stash push -- &lt;file&gt;
</code></pre></li></ul><h3 id=二git-tag頒發正式證書標記穩定版本>二、<code>git tag</code>：頒發正式證書（標記穩定版本）</h3><p><code>git tag</code> 用於為歷史中的某個特定 Commit 打上一個「<strong>永久的、有意義的名稱標籤</strong>」。在 Git Flow 中，它通常在 <code>main</code> 分支上發佈新版本時使用。</p><h4 id=1-定義-1>1. 定義</h4><ul><li><strong>定義：</strong> 一個靜態的指標，一旦創建就不應被移動或改變。它代表了專案歷史中的一個<strong>里程碑</strong>。</li></ul><h4 id=2-兩種標籤與指令>2. 兩種標籤與指令</h4><table><thead><tr><th>類型</th><th>說明</th><th>適用情境</th></tr></thead><tbody><tr><td><strong>輕量標籤 (Lightweight)</strong></td><td>僅是一個指標，沒有額外資訊，像分支一樣。</td><td>臨時的標記點，例如記錄測試通過點。</td></tr><tr><td><strong>註解標籤 (Annotated)</strong></td><td>儲存標籤作者、日期、訊息等額外資訊。</td><td><strong>正式版本發佈</strong>（如 <code>v1.0.0</code>），這是業界標準。</td></tr></tbody></table><ul><li><strong>指令：</strong><pre tabindex=0><code># 創建註解標籤（正式發佈用）
git tag -a v1.0.0 -m &#34;版本 1.0.0：實施客戶登入與購物車功能&#34;

# 查看所有標籤
git tag 

# 預設 git push 不會推送標籤，需要額外推送
git push origin --tags 
</code></pre></li></ul><h3 id=三git-grep程式碼快速搜尋引擎定位內容>三、<code>git grep</code>：程式碼快速搜尋引擎（定位內容）</h3><p><code>git grep</code> 是一個強大且高效的工具，專門用於在 Git 追蹤的檔案中，以極快的速度搜尋程式碼內容。它比系統內建的 <code>grep</code> 更適合用於 Git 專案，因為它可以過濾掉不需要搜尋的檔案（如 <code>.git/</code> 內的檔案），甚至能在歷史 Commit 中進行搜尋。</p><h4 id=1-定義-2>1. 定義</h4><ul><li><strong>定義：</strong> 一個專門針對 Git 倉庫優化的文字搜尋工具，能夠在工作目錄、暫存區或任何歷史 Commit 中查找匹配的字串或正規表達式。</li></ul><h4 id=2-發生情境與指令-1>2. 發生情境與指令</h4><ul><li><strong>情境 A (快速查找)：</strong> 你需要找出專案中所有使用到特定常數 <code>API_KEY_SECRET</code> 的位置。</li><li><strong>情境 B (歷史追蹤)：</strong> 你想知道 <code>v1.0.0</code> 版本中，某個被移除的舊函數 <code>old_function_name</code> 在哪些檔案裡存在過。</li><li><strong>指令：</strong><pre tabindex=0><code># 在所有追蹤檔案中，搜尋 &#39;todo&#39; 並顯示行號 (-n)
git grep -n &#34;todo&#34; 

# 搜尋所有分支中，包含特定文字的檔案
git grep &#34;FIXME&#34; $(git for-each-ref --format=&#39;%(refname)&#39; refs/heads)

# 搜尋某個特定的歷史 Commit 中是否包含 &#39;refactor&#39; 關鍵字
git grep &#34;refactor&#34; &lt;commit-hash&gt;

# 僅在 .js 和 .ts 檔案中搜尋
git grep &#34;interface&#34; -- \*.js \*.ts
</code></pre></li></ul><h4 id=四git-reflog歷史操作紀錄簿究極安全網>四、<code>git reflog</code>：歷史操作紀錄簿（究極安全網）</h4><p><code>git reflog</code> 可能是 Git 中<strong>最重要的「救命稻草」</strong>。它記錄了<strong>所有</strong>對你本地 Git 倉庫的變動（包括 Commit、Reset、Rebase、Checkout 等）。</p><h4 id=1-定義-3>1. 定義</h4><ul><li><strong>定義：</strong> Reflog (Reference Logs) 是一個本地的<strong>私有日誌</strong>，記錄了你的 <code>HEAD</code> 在過去幾分鐘、幾小時內曾經「指向」過的所有 Commit 紀錄。</li></ul><h4 id=2-發生情境與指令-2>2. 發生情境與指令</h4><ul><li><strong>情境：</strong> 你不小心執行了 <code>git reset --hard</code>，刪除了重要的本地 Commit，或執行 <code>git rebase</code> 後發生了嚴重的錯誤。</li><li><strong>指令：</strong><pre tabindex=0><code># 顯示 HEAD 過去的移動紀錄
git reflog 
# 輸出範例：HEAD@{0} 是當前位置，HEAD@{1} 是上一步...

# 拯救失誤：假設你看到 HEAD@{5} 是你想要的 Commit ID，則執行
git reset --hard HEAD@{5} 
# 這樣就能將你的分支和 HEAD 指標安全地移動到該位置，恢復「已刪除」的 Commit。
</code></pre></li></ul><h3 id=小結><strong>小結</strong></h3><p>這四個工具涵蓋了 Git 進階應用的核心：<code>stash</code> 讓你保持靈活性，<code>tag</code> 讓你正式發佈，而 <code>reflog</code> 則確保你永遠不會因為失誤而丟失工作。掌握它們，你的 Git 技能樹就完整了！</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>285 words</span>
<span>5 - 6 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><ul><li><a href=#一git-stash臨時置物櫃應對緊急插單>一、<code>git stash</code>：臨時置物櫃（應對緊急插單）</a></li><li><a href=#二git-tag頒發正式證書標記穩定版本>二、<code>git tag</code>：頒發正式證書（標記穩定版本）</a></li><li><a href=#三git-grep程式碼快速搜尋引擎定位內容>三、<code>git grep</code>：程式碼快速搜尋引擎（定位內容）</a></li><li><a href=#小結><strong>小結</strong></a></li></ul></li></ul></nav><h3>Related</h3><ul><li><a href=/posts/post_git_17/>Git 系列分享 - p.15 `git flow`</a></li><li><a href=/posts/post_git_16/>Git 系列分享 - p.14 啟動協作：git fork 與 git clone 的差異</a></li><li><a href=/posts/post_git_15/>Git 系列分享 - p.13 遠端協作的橋樑：`git remote`、`git pull` 與 `git push`</a></li><li><a href=/posts/post_git_14/>Git 系列分享 - p.12 歷史控制：`git reset`、`git revert` 與 `git cherry-pick`</a></li><li><a href=/posts/post_git_13/>Git 系列分享 - p.11 歷史重寫與整理：`git rebase` 和 `squash` 的魔法</a></li></ul></aside></div></div></body></html>