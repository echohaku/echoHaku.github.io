<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Git 系列分享 - p.11 歷史重寫與整理：`git rebase` 和 `squash` 的魔法 | ECHOHAKU BLOG</title><link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://echoHaku.github.io/posts/post_git_13/"><meta property="og:site_name" content="ECHOHAKU BLOG"><meta property="og:title" content="Git 系列分享 - p.11 歷史重寫與整理：`git rebase` 和 `squash` 的魔法"><meta property="og:description" content="在Git 系列分享 - p.10 整合工作線：git merge 的兩種策略與原理中，我們確認了 git merge 是將分散的工作線安全整合回主線的最佳且非破壞性（Non-destructive）的方式。 然而，Git 還有另一種強大的工具，它可以讓你的歷史紀錄看起來像一條筆直的直線、乾淨無比。這個工具就是 git rebase（歷史重寫）。 Rebase 並非用來「合併」 Commit，而是用來「移動」或「重新編排」 Commit 的歷史。
一、git rebase：歷史線的「搬家與重寫」工程 git rebase 顧名思義就是 Re-base，改變分支的基礎（Base）。它的核心目的，是讓你的分支看起來像是從目標分支的最新 Commit 之後才開始開發的。（也就是你的修改會在原分支的最後）
1. Rebase 的原理與比喻 比喻： 想像你有一張藍色便利貼（feature 分支），它本來貼在日記的第 5 頁（舊 Commit）。現在，主線（main）日記已經寫到了第 10 頁。 Merge 的做法： 產生一張「合併」頁面（第 11 頁），同時指著第 10 頁和藍色便利貼。 Rebase 的做法： 拆下： 把藍色便利貼上的內容（你的 Commit 紀錄）暫時拆下來。 重抄： 把這些內容一頁一頁地，按照順序重新抄寫到日記本的最新頁面（第 10 頁）後面。 移動： 藍色便利貼（feature 指標）現在貼在新的第 13 頁（新的 Commit）。 結果： 你的 feature 分支看起來是從第 10 頁直接往後接的，歷史記錄變成一條筆直的直線。 2. Rebase 的核心差異：重寫歷史 Rebase 在重抄 Commit 內容時，會產生全新的 Commit SHA 雜湊值（即新的版本編號）。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-13T08:39:49+08:00"><meta property="article:modified_time" content="2025-11-13T08:39:49+08:00"><meta property="article:tag" content="Git"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git 系列分享 - p.11 歷史重寫與整理：`git rebase` 和 `squash` 的魔法"><meta name=twitter:description content="在Git 系列分享 - p.10 整合工作線：git merge 的兩種策略與原理中，我們確認了 git merge 是將分散的工作線安全整合回主線的最佳且非破壞性（Non-destructive）的方式。 然而，Git 還有另一種強大的工具，它可以讓你的歷史紀錄看起來像一條筆直的直線、乾淨無比。這個工具就是 git rebase（歷史重寫）。 Rebase 並非用來「合併」 Commit，而是用來「移動」或「重新編排」 Commit 的歷史。
一、git rebase：歷史線的「搬家與重寫」工程 git rebase 顧名思義就是 Re-base，改變分支的基礎（Base）。它的核心目的，是讓你的分支看起來像是從目標分支的最新 Commit 之後才開始開發的。（也就是你的修改會在原分支的最後）
1. Rebase 的原理與比喻 比喻： 想像你有一張藍色便利貼（feature 分支），它本來貼在日記的第 5 頁（舊 Commit）。現在，主線（main）日記已經寫到了第 10 頁。 Merge 的做法： 產生一張「合併」頁面（第 11 頁），同時指著第 10 頁和藍色便利貼。 Rebase 的做法： 拆下： 把藍色便利貼上的內容（你的 Commit 紀錄）暫時拆下來。 重抄： 把這些內容一頁一頁地，按照順序重新抄寫到日記本的最新頁面（第 10 頁）後面。 移動： 藍色便利貼（feature 指標）現在貼在新的第 13 頁（新的 Commit）。 結果： 你的 feature 分支看起來是從第 10 頁直接往後接的，歷史記錄變成一條筆直的直線。 2. Rebase 的核心差異：重寫歷史 Rebase 在重抄 Commit 內容時，會產生全新的 Commit SHA 雜湊值（即新的版本編號）。"><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.3ecaab62029c68421263b320760b1d99eb62d6f48764aab41f3d427c5686d178.css integrity="sha256-PsqrYgKcaEISY7Mgdgsdmeti1vSHZKq0Hz1CfFaG0Xg=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://echoHaku.github.io/ style=color:inherit>ECHOHAKU BLOG</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://echoHaku.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://echoHaku.github.io/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Git 系列分享 - p.11 歷史重寫與整理：`git rebase` 和 `squash` 的魔法</h1><time class=dim datetime=2025-11-13T08:39:49+08:00>November 13, 2025</time><div class=term-container><div class=tag><a href=https://echoHaku.github.io/tags/git/>#Git</a></div></ol></div><section class=page-section><p>在<a href=/posts/post_git_12/>Git 系列分享 - p.10 整合工作線：<code>git merge</code> 的兩種策略與原理</a>中，我們確認了 <code>git merge</code> 是將分散的工作線安全整合回主線的最佳且非破壞性（Non-destructive）的方式。
然而，Git 還有另一種強大的工具，它可以讓你的歷史紀錄看起來像一條筆直的直線、乾淨無比。這個工具就是 <strong><code>git rebase</code></strong>（歷史重寫）。
Rebase 並非用來「合併」 Commit，而是用來「<strong>移動</strong>」或「<strong>重新編排</strong>」 Commit 的歷史。</p><h3 id=一git-rebase歷史線的搬家與重寫工程>一、<code>git rebase</code>：歷史線的「搬家與重寫」工程</h3><p><code>git rebase</code> 顧名思義就是 <strong>Re-base</strong>，改變分支的基礎（Base）。它的核心目的，是讓你的分支看起來像是從目標分支的<strong>最新 Commit 之後才開始開發的</strong>。（也就是你的修改會在原分支的最後）</p><h4 id=1-rebase-的原理與比喻>1. Rebase 的原理與比喻</h4><ul><li><strong>比喻：</strong> 想像你有一張藍色便利貼（<code>feature</code> 分支），它本來貼在日記的第 5 頁（舊 Commit）。現在，主線（<code>main</code>）日記已經寫到了第 10 頁。</li><li><strong>Merge 的做法：</strong> 產生一張「合併」頁面（第 11 頁），同時指著第 10 頁和藍色便利貼。</li><li><strong>Rebase 的做法：</strong><ol><li><strong>拆下：</strong> 把藍色便利貼上的內容（你的 Commit 紀錄）<strong>暫時拆下來</strong>。</li><li><strong>重抄：</strong> 把這些內容<strong>一頁一頁地</strong>，按照順序重新抄寫到日記本的最新頁面（第 10 頁）後面。</li><li><strong>移動：</strong> 藍色便利貼（<code>feature</code> 指標）現在貼在新的第 13 頁（新的 Commit）。</li></ol></li><li><strong>結果：</strong> 你的 <code>feature</code> 分支看起來是從第 10 頁直接往後接的，歷史記錄變成一條筆直的直線。</li></ul><h4 id=2-rebase-的核心差異重寫歷史>2. Rebase 的核心差異：重寫歷史</h4><p>Rebase 在重抄 Commit 內容時，會產生<strong>全新的 Commit SHA 雜湊值</strong>（即新的版本編號）。</p><ul><li><strong>Merge：</strong> 保留舊的 SHA，產生一個新的 Merge Commit。</li><li><strong>Rebase：</strong> 捨棄舊的 SHA，為每個被移動的 Commit <strong>產生全新的 SHA</strong>。</li></ul><p><strong>🚨 關鍵警告：</strong> 會捨棄舊的SHA，這就是 Rebase 被稱為<strong>破壞性操作</strong>的原因。</p><h4 id=3-核心指令與情境>3. 核心指令與情境</h4><table><thead><tr><th>指令</th><th>作用說明</th><th>適用情境</th></tr></thead><tbody><tr><td><code>git rebase &lt;base-branch></code></td><td>將當前分支的 Commit 重新建立在 <code>&lt;base-branch></code> 的最新 Commit 之後。</td><td>讓本地功能分支永遠保持在主線的最新狀態。</td></tr><tr><td><code>git rebase -i &lt;commit-hash></code></td><td><strong>互動式 Rebase</strong>，開啟編輯器，允許你對 Commit 進行編輯、刪除、合併（Squash）等操作。</td><td>清理本地歷史、修改 Commit Message。</td></tr></tbody></table><h4 id=４-要如何取消-rebase>４. 要如何取消 <code>rebase</code></h4><ul><li>第一種方式，用<code>git reflog</code>找到 &ldquo;rebase:&mldr;.&rdquo; 相關紀錄的前一個commit，然後reset 回去 (<code>git reset 該commitId --hard或--soft或--mixed</code>)</li><li>第二種方式，利用<a href=/posts/post_git_11/>Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD</a> 所說的 <code>ORIG_HEAD</code>這個特殊pointer，reset到該pointer指向的commit (<code>git reset ORIG_HEAD --hard或--soft或--mixed</code>)</li></ul><h3 id=二git-squash將多頁日記壓縮成一頁>二、<code>git squash</code>：將多頁日記壓縮成一頁</h3><p><code>git squash</code>（壁球/壓縮）本身並不是一個 Git 指令，而是<strong>互動式 Rebase</strong> 中的一個<strong>動作選項</strong>。它的目的是將多個微小、中途的 Commit 壓縮成一個單一、乾淨、邏輯完整的 Commit。</p><h4 id=1-為什麼需要-squash>1. 為什麼需要 Squash？</h4><p>在開發功能時，你可能會提交很多「瑣碎」的 Commit：</p><ul><li><code>fix: 修正昨天的錯字</code></li><li><code>temp: 存一下怕斷電</code></li><li><code>style: 調整空格</code></li><li><code>feat: 完成登入按鈕</code> (最終 Commit)</li></ul><p>如果把這四個 Commit 都 Merge 到主線，會讓歷史紀錄非常混亂。透過 Squash，你可以將這四個 Commit 壓縮成一個：</p><ul><li><code>feat: 完成使用者登入功能</code></li></ul><p>這樣主線歷史只會看到一個乾淨、完整的 Commit。</p><h4 id=2-執行-squash-的步驟使用互動式-rebase>2. 執行 Squash 的步驟（使用互動式 Rebase）</h4><p>Squash 必須在 <strong><code>git rebase -i</code></strong> 互動式介面中完成：</p><ol><li><strong>選擇範圍：</strong> 決定從哪個 Commit 開始向前整理。例如：你想整理<strong>最後 3 個</strong> Commit。<pre tabindex=0><code># 選擇 HEAD 往前數 3 個 Commit 之前的 Commit 作為 Base
git rebase -i HEAD~3 
</code></pre></li><li><strong>編輯清單：</strong> 終端機會打開編輯器，顯示這 3 個 Commit 的清單。你需要修改清單中的指令：<pre tabindex=0><code>pick 1a2b3c4 fix: 修正錯字
squash 4d5e6f7 temp: 存一下怕斷電  &lt;-- 將此 Commit 壓縮到上一個
squash 7g8h9i0 style: 調整空格   &lt;-- 將此 Commit 壓縮到上一個
pick 1j2k3l4 feat: 完成登入按鈕   &lt;-- 保持獨立
</code></pre></li><li><strong>重新編寫訊息：</strong> Git 會讓你編輯新的 Commit Message。你可以在這裡將四個 Commit 的訊息整合成一個乾淨的摘要。</li><li><strong>結果：</strong> 原始的 3 個 Commit 會消失，並被 1 或 2 個新的 Commit 取代，<strong>Commit SHA 也會改變</strong>。</li></ol><h3 id=三關鍵警告絕不-rebase-已共享的分支>三、關鍵警告：絕不 Rebase 已共享的分支</h3><p>Rebase 是處理本地工作（你自己的便利貼）的最佳工具，但對團隊協作而言卻是高風險。</p><h4 id=為什麼不能-rebase-已推送到遠端共享的分支><strong>為什麼不能 Rebase 已推送到遠端（共享）的分支？</strong></h4><ol><li><strong>歷史分歧：</strong> 當你 Rebase 並強制推送（<code>git push --force</code>）後，遠端分支的歷史將被重寫。</li><li><strong>隊友困境：</strong> 你的隊友如果已經基於舊的歷史（舊的 SHA）進行了開發，當他們嘗試拉取（Pull）最新的遠端分支時，Git 會發現「歷史突然倒退或改變了」，導致他們必須進行複雜的歷史修復操作（例如 <code>git pull --rebase</code>），這會對團隊造成極大的干擾。</li></ol><ul><li><strong>鐵則：</strong> <strong>如果你能用 <code>git merge</code> 解決，就不要用 <code>git rebase</code>。</strong></li></ul><h3 id=四值得分享的知識點rebase-與-merge-的最終抉擇>四、值得分享的知識點：Rebase 與 Merge 的最終抉擇</h3><table><thead><tr><th>項目</th><th><code>git merge</code></th><th><code>git rebase</code></th></tr></thead><tbody><tr><td><strong>歷史外觀</strong></td><td>歷史線分岔後匯合（有分岔點），<strong>保留真實的開發歷程</strong>。</td><td>歷史線被重寫成一條直線，<strong>歷史乾淨但非真實發生</strong>。</td></tr><tr><td><strong>Commit SHA</strong></td><td>原始 Commit SHA <strong>不變</strong>。</td><td>所有被移動的 Commit SHA <strong>都會改變</strong>。</td></tr><tr><td><strong>安全性</strong></td><td><strong>高</strong>。非破壞性操作，適用於任何分支。</td><td><strong>低</strong>。破壞性操作，<strong>絕不應用於已共享的遠端分支</strong>。</td></tr><tr><td><strong>主要目的</strong></td><td><strong>整合</strong>不同分支的工作。</td><td><strong>清理</strong>本地歷史紀錄。</td></tr></tbody></table><ul><li><strong>實務建議總結：</strong><ol><li>在你的<strong>本地 <code>feature</code> 分支</strong>上，用 <code>git rebase -i</code> 進行清理（Squash/Fixup）。</li><li>當你要將 <code>feature</code> 整合回 <code>main</code> 時，請使用 <strong><code>git merge --no-ff</code></strong>。</li></ol></li></ul><h3 id=小結><strong>小結</strong></h3><p><code>git rebase</code> 和 <code>git squash</code> 賦予了你修改歷史的能力，讓你能夠提交一份整潔、專業且邏輯連貫的 Commit 紀錄。但「能力越大，責任越大」，請務必遵守「不 Rebase 已共享歷史」的鐵則。</p><p>在下一篇文章中，我們將學習 Git 中處理「失誤」和「變更」的三大指令：<code>git reset</code>、<code>git revert</code>，以及如何精準「複製」Commit 的 <code>git cherry-pick</code>！</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>361 words</span>
<span>6 - 8 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><ul><li><a href=#一git-rebase歷史線的搬家與重寫工程>一、<code>git rebase</code>：歷史線的「搬家與重寫」工程</a></li><li><a href=#二git-squash將多頁日記壓縮成一頁>二、<code>git squash</code>：將多頁日記壓縮成一頁</a></li><li><a href=#三關鍵警告絕不-rebase-已共享的分支>三、關鍵警告：絕不 Rebase 已共享的分支</a></li><li><a href=#四值得分享的知識點rebase-與-merge-的最終抉擇>四、值得分享的知識點：Rebase 與 Merge 的最終抉擇</a></li><li><a href=#小結><strong>小結</strong></a></li></ul></li></ul></nav><h3>Related</h3><ul><li><a href=/posts/post_git_12/>Git 系列分享 - p.10 整合工作線：`git merge` 的兩種策略與原理</a></li><li><a href=/posts/post_git_11/>Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD</a></li><li><a href=/posts/post_git_9/>Git 系列分享 - p.7 版本控制的篩選器 - .gitignore 的使用與規則</a></li><li><a href=/posts/post_git_10/>Git 系列分享 - p.8 Git 的核心力量 - 分支 (Branch)</a></li><li><a href=/posts/post_git_8/>Git 系列分享 - p.6 正式提交一個commit囉</a></li></ul></aside></div></div></body></html>