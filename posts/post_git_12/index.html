<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Git 系列分享 - p.10 整合工作線：`git merge` 的兩種策略與原理 | ECHOHAKU BLOG</title><link rel=icon href=favicon.svg sizes=any type=image/svg+xml><meta property="og:url" content="https://echoHaku.github.io/posts/post_git_12/"><meta property="og:site_name" content="ECHOHAKU BLOG"><meta property="og:title" content="Git 系列分享 - p.10 整合工作線：`git merge` 的兩種策略與原理"><meta property="og:description" content="在 Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD 中，我們學會了如何使用分支來安全地隔離工作。現在，當你在 feature 分支上的新功能開發完成後，我們就需要將它與主線（main 分支）的工作整合在一起。
這個「整合」的動作，就是由 git merge 指令來完成的。
一、git merge 的目的：將分散的工作線匯集 git merge 的核心目的只有一個：將目標分支（通常是你的新功能分支）的歷史紀錄，融合到當前你所在的分支（通常是主線 main）中。
在執行合併前，你必須先用 git switch 切換到「接收變更」的分支：
# 假設要將 feature/login 合併到 main git switch main # 1. 確保 HEAD 在接收變更的分支上 (main) git merge feature/login # 2. 執行合併，目標分支為 feature/login 根據兩個分支的歷史關係，git merge 會自動採用以下兩種主要策略之一：
二、策略一：Fast-Forward (快轉合併) 如果目標分支（feature）是從當前分支（main）的最新 Commit 之後開始開發，並且 main 分支在 feature 分支開發期間沒有任何新的 Commit，Git 就會採用 Fast-Forward 策略。
1. 合併原理 比喻： 就像你在交換日記中新增了一頁內容，但中間沒有任何人寫過。 動作： Git 不會產生新的 Commit。它只會將 main 分支的指標（便利貼）直接移動到 feature 分支的最新 Commit 上。 結果： 分支歷史呈現一條直線，非常簡潔。 2. 優缺點與情境 項目 說明 優點 歷史線最乾淨，沒有多餘的 Commit 節點。 缺點 會遺失分支資訊：一旦合併，你看 git log 時，會看不出來這些 Commit 是屬於哪個 feature 分支的工作。 情境 適用於短暫、單一目標的分支，且你不介意失去「分支記錄」時。 三、策略二：Three-way Merge (三方合併/非快轉) 如果當前分支（main）在你開發 feature 分支的期間，也有了新的 Commit（例如其他人提交的 Hotfix），那麼兩個分支的歷史就會產生分岔。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-12T08:57:17+08:00"><meta property="article:modified_time" content="2025-11-12T08:57:17+08:00"><meta property="article:tag" content="Git"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git 系列分享 - p.10 整合工作線：`git merge` 的兩種策略與原理"><meta name=twitter:description content="在 Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD 中，我們學會了如何使用分支來安全地隔離工作。現在，當你在 feature 分支上的新功能開發完成後，我們就需要將它與主線（main 分支）的工作整合在一起。
這個「整合」的動作，就是由 git merge 指令來完成的。
一、git merge 的目的：將分散的工作線匯集 git merge 的核心目的只有一個：將目標分支（通常是你的新功能分支）的歷史紀錄，融合到當前你所在的分支（通常是主線 main）中。
在執行合併前，你必須先用 git switch 切換到「接收變更」的分支：
# 假設要將 feature/login 合併到 main git switch main # 1. 確保 HEAD 在接收變更的分支上 (main) git merge feature/login # 2. 執行合併，目標分支為 feature/login 根據兩個分支的歷史關係，git merge 會自動採用以下兩種主要策略之一：
二、策略一：Fast-Forward (快轉合併) 如果目標分支（feature）是從當前分支（main）的最新 Commit 之後開始開發，並且 main 分支在 feature 分支開發期間沒有任何新的 Commit，Git 就會採用 Fast-Forward 策略。
1. 合併原理 比喻： 就像你在交換日記中新增了一頁內容，但中間沒有任何人寫過。 動作： Git 不會產生新的 Commit。它只會將 main 分支的指標（便利貼）直接移動到 feature 分支的最新 Commit 上。 結果： 分支歷史呈現一條直線，非常簡潔。 2. 優缺點與情境 項目 說明 優點 歷史線最乾淨，沒有多餘的 Commit 節點。 缺點 會遺失分支資訊：一旦合併，你看 git log 時，會看不出來這些 Commit 是屬於哪個 feature 分支的工作。 情境 適用於短暫、單一目標的分支，且你不介意失去「分支記錄」時。 三、策略二：Three-way Merge (三方合併/非快轉) 如果當前分支（main）在你開發 feature 分支的期間，也有了新的 Commit（例如其他人提交的 Hotfix），那麼兩個分支的歷史就會產生分岔。"><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.3ecaab62029c68421263b320760b1d99eb62d6f48764aab41f3d427c5686d178.css integrity="sha256-PsqrYgKcaEISY7Mgdgsdmeti1vSHZKq0Hz1CfFaG0Xg=" crossorigin=anonymous><script src=/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://echoHaku.github.io/ style=color:inherit>ECHOHAKU BLOG</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://echoHaku.github.io/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://echoHaku.github.io/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Git 系列分享 - p.10 整合工作線：`git merge` 的兩種策略與原理</h1><time class=dim datetime=2025-11-12T08:57:17+08:00>November 12, 2025</time><div class=term-container><div class=tag><a href=https://echoHaku.github.io/tags/git/>#Git</a></div></ol></div><section class=page-section><p>在 <a href=/posts/post_git_11/>Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD</a> 中，我們學會了如何使用分支來安全地隔離工作。現在，當你在 <code>feature</code> 分支上的新功能開發完成後，我們就需要將它與主線（<code>main</code> 分支）的工作<strong>整合</strong>在一起。</p><p>這個「整合」的動作，就是由 <strong><code>git merge</code></strong> 指令來完成的。</p><h3 id=一git-merge-的目的將分散的工作線匯集>一、<code>git merge</code> 的目的：將分散的工作線匯集</h3><p><code>git merge</code> 的核心目的只有一個：將目標分支（通常是你的新功能分支）的歷史紀錄，融合到當前你所在的分支（通常是主線 <code>main</code>）中。</p><p>在執行合併前，你必須先用 <code>git switch</code> <strong>切換到「接收變更」的分支</strong>：</p><pre tabindex=0><code># 假設要將 feature/login 合併到 main 
git switch main   # 1. 確保 HEAD 在接收變更的分支上 (main)
git merge feature/login # 2. 執行合併，目標分支為 feature/login
</code></pre><p>根據兩個分支的歷史關係，<code>git merge</code> 會自動採用以下兩種主要策略之一：</p><h3 id=二策略一fast-forward-快轉合併>二、策略一：Fast-Forward (快轉合併)</h3><p>如果目標分支（<code>feature</code>）是從當前分支（<code>main</code>）的最新 Commit 之後開始開發，並且 <code>main</code> 分支在 <code>feature</code> 分支開發期間<strong>沒有任何新的 Commit</strong>，Git 就會採用 Fast-Forward 策略。</p><h4 id=1-合併原理>1. 合併原理</h4><ul><li><strong>比喻：</strong> 就像你在交換日記中新增了一頁內容，但中間沒有任何人寫過。</li><li><strong>動作：</strong> Git 不會產生新的 Commit。它只會將 <code>main</code> 分支的指標（便利貼）<strong>直接移動</strong>到 <code>feature</code> 分支的最新 Commit 上。</li><li><strong>結果：</strong> 分支歷史呈現一條直線，非常簡潔。</li></ul><h4 id=2-優缺點與情境>2. 優缺點與情境</h4><table><thead><tr><th>項目</th><th>說明</th></tr></thead><tbody><tr><td><strong>優點</strong></td><td>歷史線最乾淨，沒有多餘的 Commit 節點。</td></tr><tr><td><strong>缺點</strong></td><td><strong>會遺失分支資訊</strong>：一旦合併，你看 <code>git log</code> 時，會看不出來這些 Commit 是屬於哪個 <code>feature</code> 分支的工作。</td></tr><tr><td><strong>情境</strong></td><td>適用於短暫、單一目標的分支，且你不介意失去「分支記錄」時。</td></tr></tbody></table><h3 id=三策略二three-way-merge-三方合併非快轉>三、策略二：Three-way Merge (三方合併/非快轉)</h3><p>如果當前分支（<code>main</code>）在你開發 <code>feature</code> 分支的期間，也<strong>有了新的 Commit</strong>（例如其他人提交的 Hotfix），那麼兩個分支的歷史就會產生分岔。</p><p>此時，Git 必須找到一個<strong>共同祖先</strong>，然後將三點（共同祖先、<code>main</code> 最新 Commit、<code>feature</code> 最新 Commit）的差異進行融合。</p><h4 id=1-合併原理-1>1. 合併原理</h4><ul><li><strong>比喻：</strong> 像你們兩人同時在日記的同一頁之後寫了不同的內容。</li><li><strong>動作：</strong> Git 會產生一個<strong>新的 Commit</strong>，這個 Commit 會有<strong>兩個父 Commit</strong>（一個是 <code>main</code> 的最新 Commit，一個是 <code>feature</code> 的最新 Commit）。</li><li><strong>結果：</strong> 歷史線會交會，形成一個 <strong>&ldquo;Merge Commit&rdquo;</strong> 節點。</li></ul><h4 id=2-優缺點與情境-1>2. 優缺點與情境</h4><table><thead><tr><th>項目</th><th>說明</th></tr></thead><tbody><tr><td><strong>優點</strong></td><td><strong>保留分支紀錄</strong>：這個 Commit 節點清楚地顯示了某個功能分支（<code>feature</code>）是在哪個時間點被完整整合進主線（<code>main</code>）的。</td></tr><tr><td><strong>缺點</strong></td><td>會產生一個額外的 Commit 節點（Merge Commit）。</td></tr><tr><td><strong>情境</strong></td><td>適用於<strong>所有長期分支</strong>或<strong>多人協作</strong>的主線整合。<strong>這是團隊開發的標準做法。</strong></td></tr></tbody></table><h3 id=四強制執行三方合併---no-ff>四、強制執行三方合併 (<code>--no-ff</code>)</h3><p>有時即使 Git 可以進行 Fast-Forward 合併（即 <code>main</code> 沒有新的 Commit），但為了保留「分支紀錄」，我們也會<strong>強制執行三方合併</strong>：</p><pre tabindex=0><code>git merge --no-ff feature/login
</code></pre><ul><li>這個旗標會告訴 Git：即使可以快轉，<strong>請務必產生一個 Merge Commit</strong>。這樣能清楚標註一個新功能開始和結束的範圍。</li></ul><h3 id=五當合併發生問題時衝突-conflict>五、當合併發生問題時：衝突 (Conflict)</h3><p>當 <code>git merge</code> 嘗試融合兩個分支時，如果發現<strong>兩個分支對同一個檔案的同一行內容進行了不同的修改</strong>，Git 就無法自動判斷該保留哪一個。這時就會發生 <strong>&ldquo;Merge Conflict&rdquo;</strong>（合併衝突）。
<strong>合併分支的時候，遇到衝突是非常正常的情況</strong>，表示這份文件不只有你有動到，同時也代表需要更細心一些避免自己的修改影響到他人的功能。有時可以簡單的用「resolve using theirs」或「resolve using mine」但若同時需要保留兩邊的程式碼，那就是再加上人為的判斷，這都是很正常的！</p><h4 id=1-發生情境>1. 發生情境</h4><ul><li><strong>同時修改同一行：</strong> 你改了第 10 行，小明也改了第 10 行。</li></ul><h4 id=2-解決步驟>2. 解決步驟</h4><ol><li><p><strong><code>git status</code>：</strong> Git 會提示哪些檔案發生了衝突（顯示為 <code>unmerged</code>）。</p></li><li><p><strong>手動編輯：</strong> 打開衝突的檔案，你會看到以下標記：</p><pre tabindex=0><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
這裡是你（main 分支）的內容
=======
這裡是目標分支（feature/login）的內容
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/login
</code></pre></li><li><p><strong>選擇內容：</strong> 手動刪除標記符號（<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>>>>>>>></code>、<code>======</code>），只保留你最終想要留下的程式碼。</p></li><li><p><strong><code>git add &lt;file></code>：</strong> 將解決衝突後的檔案加入存區。</p></li><li><p><strong><code>git commit</code>：</strong> 提交這個「解決衝突的合併結果」。</p></li></ol><h3 id=小結><strong>小結</strong></h3><p><code>git merge</code> 是 Git 協作的終點站。了解 Fast-Forward 與 Three-way 兩種策略，並知道如何在衝突時手動介入，你就能自如地將任何分支上的工作整合進專案主線中。在下一章我們將介紹<code>git rebase</code>，這是另外一種比較具有風險的合併分支的方式，讓我們靜待下一章節吧。<a href=/posts/post_git_13/>Git 系列分享 - p.11 歷史重寫與整理：<code>git rebase</code> 和 <code>squash</code> 的魔法</a></p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2026</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>236 words</span>
<span>5 - 7 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><ul><li><a href=#一git-merge-的目的將分散的工作線匯集>一、<code>git merge</code> 的目的：將分散的工作線匯集</a></li><li><a href=#二策略一fast-forward-快轉合併>二、策略一：Fast-Forward (快轉合併)</a></li><li><a href=#三策略二three-way-merge-三方合併非快轉>三、策略二：Three-way Merge (三方合併/非快轉)</a></li><li><a href=#四強制執行三方合併---no-ff>四、強制執行三方合併 (<code>--no-ff</code>)</a></li><li><a href=#五當合併發生問題時衝突-conflict>五、當合併發生問題時：衝突 (Conflict)</a></li><li><a href=#小結><strong>小結</strong></a></li></ul></li></ul></nav><h3>Related</h3><ul><li><a href=/posts/post_git_11/>Git 系列分享 - p.9 你的當前位置：HEAD、DETACHED HEAD 與 ORIG_HEAD</a></li><li><a href=/posts/post_git_9/>Git 系列分享 - p.7 版本控制的篩選器 - .gitignore 的使用與規則</a></li><li><a href=/posts/post_git_10/>Git 系列分享 - p.8 Git 的核心力量 - 分支 (Branch)</a></li><li><a href=/posts/post_git_8/>Git 系列分享 - p.6 正式提交一個commit囉</a></li><li><a href=/posts/post_git_7/>Git 系列分享 - p.5 檔案追蹤並納入紀錄！（git status、git add）</a></li></ul></aside></div></div></body></html>